# 1.1B: Database Schema & Models

## 🎯 Task Overview
**Agent**: @backend-architect
**Duration**: 6 hours
**Dependencies**: 1.1A (Project Architecture)
**Risk Level**: Low
**Parallel Execution**: ❌ Depends on 1.1A

## 📋 Objective
Design and implement PostgreSQL schema for TCG Tactique with tables: users, active_cards, decks, deck_cards, games, game_states. Include TypeScript models and validation constraints specific to TCG mechanics.

## 🎯 Deliverables

### 1. Database Schema
```sql
-- Users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Active cards pool (240-360 cards in rotation)
CREATE TABLE active_cards (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    faction VARCHAR(20) CHECK (faction IN ('humans', 'aliens', 'robots')),
    type VARCHAR(20) CHECK (type IN ('unit', 'spell')),
    cost INTEGER CHECK (cost BETWEEN 1 AND 10),
    attack INTEGER, -- NULL for spells
    hp INTEGER,     -- NULL for spells
    range VARCHAR(10), -- Ex: "1-2", "3" for units
    effects TEXT[], -- Array of effects
    set_id VARCHAR(20), -- Rotation set identifier
    created_at TIMESTAMP DEFAULT NOW()
);

-- User decks (exactly 40 cards)
CREATE TABLE decks (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(50) NOT NULL,
    faction VARCHAR(20) CHECK (faction IN ('humans', 'aliens', 'robots')),
    is_valid BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Cards in decks (max 4 per card)
CREATE TABLE deck_cards (
    deck_id INTEGER REFERENCES decks(id) ON DELETE CASCADE,
    card_id INTEGER REFERENCES active_cards(id) ON DELETE CASCADE,
    quantity INTEGER CHECK (quantity BETWEEN 1 AND 4),
    PRIMARY KEY (deck_id, card_id)
);

-- Game sessions
CREATE TABLE games (
    id SERIAL PRIMARY KEY,
    player1_id INTEGER REFERENCES users(id),
    player2_id INTEGER REFERENCES users(id),
    player1_deck_id INTEGER REFERENCES decks(id),
    player2_deck_id INTEGER REFERENCES decks(id),
    winner_id INTEGER REFERENCES users(id),
    duration_seconds INTEGER,
    end_reason VARCHAR(50), -- 'quest_completed', 'surrender', 'deck_empty'
    created_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP
);

-- Game state snapshots
CREATE TABLE game_states (
    id SERIAL PRIMARY KEY,
    game_id INTEGER REFERENCES games(id) ON DELETE CASCADE,
    player1_id INTEGER REFERENCES users(id),
    player2_id INTEGER REFERENCES users(id),
    current_player INTEGER REFERENCES users(id),
    turn INTEGER DEFAULT 1,
    phase VARCHAR(20) DEFAULT 'resources', -- 'resources', 'draw', 'actions'
    board_state_json JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- User statistics
CREATE TABLE user_stats (
    user_id INTEGER REFERENCES users(id) PRIMARY KEY,
    total_games INTEGER DEFAULT 0,
    total_wins INTEGER DEFAULT 0,
    humans_games INTEGER DEFAULT 0,
    humans_wins INTEGER DEFAULT 0,
    aliens_games INTEGER DEFAULT 0,
    aliens_wins INTEGER DEFAULT 0,
    robots_games INTEGER DEFAULT 0,
    robots_wins INTEGER DEFAULT 0,
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### 2. Constraints & Indexes
```sql
-- Deck validation: exactly 40 cards
CREATE OR REPLACE FUNCTION validate_deck_size()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT SUM(quantity) FROM deck_cards WHERE deck_id = NEW.deck_id) > 40 THEN
        RAISE EXCEPTION 'Deck cannot have more than 40 cards';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER deck_size_check
    AFTER INSERT OR UPDATE ON deck_cards
    FOR EACH ROW EXECUTE FUNCTION validate_deck_size();

-- Performance indexes
CREATE INDEX idx_active_cards_faction ON active_cards(faction);
CREATE INDEX idx_active_cards_type ON active_cards(type);
CREATE INDEX idx_active_cards_cost ON active_cards(cost);
CREATE INDEX idx_active_cards_set ON active_cards(set_id);
CREATE INDEX idx_decks_user ON decks(user_id);
CREATE INDEX idx_decks_faction ON decks(faction);
CREATE INDEX idx_games_players ON games(player1_id, player2_id);
CREATE INDEX idx_game_states_game ON game_states(game_id);
CREATE INDEX idx_user_stats_user ON user_stats(user_id);
```

### 3. TypeScript Models
```typescript
// src/types/database.ts
export interface User {
    id: number;
    username: string;
    email: string;
    password_hash: string;
    created_at: Date;
    updated_at: Date;
}

export interface Card {
    id: number;
    name: string;
    faction: 'humans' | 'aliens' | 'robots';
    type: 'unit' | 'spell';
    cost: number; // 1-10 Void Echoes
    attack?: number; // Units only
    hp?: number; // Units only
    range?: string; // Units only, e.g. "1-2"
    effects: string[];
    set_id: string;
    created_at: Date;
}

export interface Deck {
    id: number;
    user_id: number;
    name: string;
    faction: 'humans' | 'aliens' | 'robots';
    is_valid: boolean;
    created_at: Date;
    updated_at: Date;
    cards?: DeckCard[];
}

export interface DeckCard {
    deck_id: number;
    card_id: number;
    quantity: number;
    card?: Card;
}

export interface Game {
    id: number;
    player1_id: number;
    player2_id: number;
    player1_deck_id: number;
    player2_deck_id: number;
    winner_id?: number;
    duration_seconds?: number;
    end_reason?: string;
    created_at: Date;
    ended_at?: Date;
}

export interface GameState {
    id: number;
    game_id: number;
    player1_id: number;
    player2_id: number;
    current_player: number;
    turn: number;
    phase: 'resources' | 'draw' | 'actions';
    board_state_json: BoardState;
    created_at: Date;
}

export interface BoardState {
    player1: PlayerState;
    player2: PlayerState;
    currentPlayer: number;
    turn: number;
    phase: string;
}

export interface PlayerState {
    hand: Card[];
    board: (Card | null)[][]; // 3x5 grid
    resources: number; // Void Echoes 0-10
    deck_remaining: number;
    graveyard: Card[];
    quest_id?: string; // Secret quest
}
```

### 4. Migration Scripts
```typescript
// migrations/001_initial_schema.ts
export async function up(knex: Knex): Promise<void> {
    // Users table
    await knex.schema.createTable('users', (table) => {
        table.increments('id').primary();
        table.string('username', 50).notNullable().unique();
        table.string('email', 100).notNullable().unique();
        table.string('password_hash', 255).notNullable();
        table.timestamps(true, true);
    });

    // Active cards table
    await knex.schema.createTable('active_cards', (table) => {
        table.increments('id').primary();
        table.string('name', 100).notNullable();
        table.enum('faction', ['humans', 'aliens', 'robots']).notNullable();
        table.enum('type', ['unit', 'spell']).notNullable();
        table.integer('cost').notNullable().checkBetween([1, 10]);
        table.integer('attack').nullable();
        table.integer('hp').nullable();
        table.string('range', 10).nullable();
        table.specificType('effects', 'text[]').notNullable();
        table.string('set_id', 20).notNullable();
        table.timestamp('created_at').defaultTo(knex.fn.now());
    });

    // Continue with other tables...
}
```

### 5. Seed Data
```typescript
// seeds/test_cards.ts
export async function seed(knex: Knex): Promise<void> {
    await knex('active_cards').del();

    await knex('active_cards').insert([
        // Humans
        {
            name: 'Imperial Guard',
            faction: 'humans',
            type: 'unit',
            cost: 2,
            attack: 2,
            hp: 3,
            range: '1',
            effects: ['Disciplined'],
            set_id: 'test-set-1'
        },
        {
            name: 'Heavy Bolter',
            faction: 'humans',
            type: 'unit',
            cost: 4,
            attack: 3,
            hp: 2,
            range: '1-3',
            effects: ['Suppression'],
            set_id: 'test-set-1'
        },
        // Aliens
        {
            name: 'Ripper Swarm',
            faction: 'aliens',
            type: 'unit',
            cost: 1,
            attack: 1,
            hp: 1,
            range: '1',
            effects: ['Spawning'],
            set_id: 'test-set-1'
        },
        // Robots
        {
            name: 'Necron Warrior',
            faction: 'robots',
            type: 'unit',
            cost: 3,
            attack: 2,
            hp: 3,
            range: '1-2',
            effects: ['Reanimation Protocols'],
            set_id: 'test-set-1'
        }
        // Add more test cards...
    ]);
}
```

## ✅ Acceptance Criteria

### Functional Requirements
- [ ] All tables created with proper constraints
- [ ] TypeScript interfaces match database schema exactly
- [ ] Migration scripts execute without errors
- [ ] Seed data loads successfully
- [ ] Deck validation constraints work (40 cards, max 4 per card)

### Quality Requirements
- [ ] Database normalized (3NF minimum)
- [ ] Indexes optimized for expected query patterns
- [ ] Foreign key constraints maintain referential integrity
- [ ] Check constraints validate business rules
- [ ] TypeScript types are type-safe and complete

### Performance Requirements
- [ ] Card queries < 50ms
- [ ] Deck validation < 100ms
- [ ] Game state updates < 200ms
- [ ] Batch operations optimized

## 🧪 Validation Tests

### Automated Tests
```typescript
// Test database schema
describe('Database Schema', () => {
    test('should create all tables successfully', async () => {
        // Run migrations and verify tables exist
    });

    test('should enforce deck size constraint', async () => {
        // Try to create deck with >40 cards
        // Should throw error
    });

    test('should validate card quantity limits', async () => {
        // Try to add >4 of same card
        // Should throw error
    });
});
```

### Manual Validation
```bash
# Test 1: Migration execution
npm run db:migrate

# Test 2: Seed data loading
npm run db:seed

# Test 3: Constraint validation
psql -d tcg_db -c "SELECT COUNT(*) FROM active_cards;"

# Test 4: TypeScript compilation
npm run build
```

## 🔧 SuperClaude Command

```bash
@Task "backend-architect" "Create PostgreSQL database schema for TCG Tactique with complete TypeScript integration:

DATABASE SCHEMA:
- Users table with authentication fields
- Active_cards table for 240-360 card rotation pool
- Decks table with faction constraint and validation
- Deck_cards junction table with quantity limits (max 4 per card)
- Games table for match history
- Game_states table for real-time game snapshots with JSONB board state
- User_stats table for performance tracking

BUSINESS CONSTRAINTS:
- Deck validation: exactly 40 cards per deck
- Card quantity: maximum 4 copies per card in deck
- Faction constraints: humans/aliens/robots only
- Cost validation: 1-10 Void Echoes range
- Game state validation for board positions

TYPESCRIPT MODELS:
- Complete interfaces matching database schema
- Type-safe enums for factions, card types, game phases
- GameState and BoardState interfaces for real-time state
- PlayerState interface for individual player data

MIGRATION SYSTEM:
- Database migration scripts using Knex.js
- Seed data with 15 test cards (5 per faction)
- Index optimization for query performance
- Constraint validation triggers

VALIDATION:
- All migrations run successfully
- Seed data loads without errors
- TypeScript compilation with strict mode
- Constraint violations properly caught and handled"
```

## 📊 Success Metrics
- **Migration Time**: < 30 seconds
- **Query Performance**: Card lookups < 50ms
- **Type Safety**: 100% TypeScript coverage
- **Data Integrity**: All constraints enforced

## 🔗 Dependencies & Integration
- **Requires**: 1.1A (Project Architecture)
- **Enables**: 1.1C (Backend Core), all game logic tasks
- **Integrates With**: All backend services and game logic

## 📝 Notes
- Focus on TCG-specific constraints (40-card decks, faction restrictions)
- Optimize for read-heavy workloads (card queries, deck building)
- Design game_states table for real-time updates
- Consider future card rotation system requirements