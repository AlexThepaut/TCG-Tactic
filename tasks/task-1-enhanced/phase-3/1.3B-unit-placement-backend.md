# Task 1.3B: Unit Placement Backend

**Phase**: 3 - Game Mechanics
**Priority**: Critical
**Estimated Time**: 3-4 days
**Dependencies**: Task 1.3A (Card System Foundation), Phase 2 Socket.io infrastructure

## üéØ Objective

Implement server-side logic for tactical unit placement with faction-specific formation validation, resource management, and real-time state synchronization via Socket.io.

## üìã Requirements

### Functional Requirements

#### Placement Validation System
- **Formation Enforcement**: Validate placement against faction-specific formations
- **Resource Validation**: Verify player has sufficient Void Echoes for card cost
- **Grid State Validation**: Ensure target position is empty and within formation
- **Turn Validation**: Verify it's the player's turn and in correct phase
- **Hand Validation**: Confirm card exists in player's hand

#### Game State Management
- **Board Representation**: Track 3√ó5 grid positions for both players
- **Resource Tracking**: Manage Void Echoes (0-10) for each player
- **Hand Management**: Track cards in each player's hand (max 7)
- **Phase Management**: Handle placement within action phase
- **State Persistence**: Save game state to PostgreSQL after each action

#### Real-time Synchronization
- **Socket.io Events**: Handle placement requests and broadcast updates
- **State Broadcasting**: Send updated game state to all players
- **Error Handling**: Send clear error messages for invalid placements
- **Atomic Operations**: Ensure state consistency across concurrent actions

### Technical Requirements

#### Game State Schema
```sql
-- Game states table
CREATE TABLE game_states (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID NOT NULL REFERENCES games(id),
    player1_id UUID NOT NULL,
    player2_id UUID NOT NULL,
    current_player_id UUID NOT NULL,
    turn INTEGER NOT NULL DEFAULT 1,
    phase VARCHAR(20) NOT NULL DEFAULT 'resources',
    player1_data JSONB NOT NULL,
    player2_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Game actions log
CREATE TABLE game_actions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID NOT NULL REFERENCES games(id),
    player_id UUID NOT NULL,
    action_type VARCHAR(30) NOT NULL,
    action_data JSONB NOT NULL,
    game_state_before JSONB,
    game_state_after JSONB,
    timestamp TIMESTAMP DEFAULT NOW()
);
```

#### Formation Definitions
```typescript
const FACTION_FORMATIONS = {
  humans: [ // "Tactical Phalanx" - Disciplined lines
    [false, true, true, true, false],
    [false, true, true, true, false],
    [false, true, true, true, false]
  ],
  aliens: [ // "Living Swarm" - Adaptive spread
    [false, true, true, true, false],
    [true, true, true, true, true],
    [false, false, true, false, false]
  ],
  robots: [ // "Immortal Army" - Technological superiority
    [true, true, true, true, true],
    [false, false, true, false, false],
    [false, true, true, true, false]
  ]
};
```

## üèóÔ∏è Technical Architecture

### Backend Components

#### PlacementService
```typescript
interface PlacementService {
  // Core placement logic
  validatePlacement(gameId: string, playerId: string, cardId: string, position: Position): ValidationResult;
  executeePlacement(gameId: string, playerId: string, cardId: string, position: Position): Promise<PlacementResult>;

  // Formation validation
  isValidPosition(faction: Faction, position: Position): boolean;
  getValidPositions(faction: Faction): Position[];

  // State management
  getGameState(gameId: string): Promise<GameState>;
  updateGameState(gameId: string, newState: GameState): Promise<void>;

  // Resource management
  canAffordCard(playerData: PlayerData, card: Card): boolean;
  deductResources(playerData: PlayerData, cost: number): PlayerData;
}
```

#### Game State Models
```typescript
interface GameState {
  id: string;
  gameId: string;
  player1Id: string;
  player2Id: string;
  currentPlayerId: string;
  turn: number;
  phase: 'resources' | 'draw' | 'actions';
  player1Data: PlayerData;
  player2Data: PlayerData;
  createdAt: Date;
  updatedAt: Date;
}

interface PlayerData {
  id: string;
  faction: 'humans' | 'aliens' | 'robots';
  hand: Card[];
  board: (PlacedCard | null)[][]; // 3x5 grid
  resources: number; // Current Void Echoes (0-10)
  deck: Card[]; // Remaining cards
  maxResources: number; // Maximum Void Echoes this turn
}

interface PlacedCard extends Card {
  position: Position;
  placedAt: Date;
  currentHealth: number;
  statusEffects: StatusEffect[];
}

interface Position {
  x: number; // 0-4 (columns)
  y: number; // 0-2 (rows)
}

interface ValidationResult {
  valid: boolean;
  error?: string;
  errorCode?: string;
}

interface PlacementResult {
  success: boolean;
  gameState?: GameState;
  error?: string;
  errorCode?: string;
}
```

### Socket.io Event Handlers

#### Placement Events
```typescript
// Client to Server Events
interface ClientToServerEvents {
  'game:place_unit': (data: PlaceUnitRequest, callback: (response: PlacementResponse) => void) => void;
}

interface PlaceUnitRequest {
  gameId: string;
  cardId: string;
  position: Position;
  handIndex: number; // Position in hand
}

interface PlacementResponse {
  success: boolean;
  gameState?: GameState;
  error?: string;
  errorCode?: 'INVALID_POSITION' | 'INSUFFICIENT_RESOURCES' | 'NOT_YOUR_TURN' | 'INVALID_CARD' | 'POSITION_OCCUPIED';
}

// Server to Client Events
interface ServerToClientEvents {
  'game:state_update': (gameState: GameState) => void;
  'game:placement_result': (result: PlacementResult) => void;
  'game:error': (error: { message: string; code: string }) => void;
}
```

#### Socket Event Implementation
```typescript
// Place unit event handler
socket.on('game:place_unit', async (data: PlaceUnitRequest, callback) => {
  try {
    // Validate request
    const validation = await placementService.validatePlacement(
      data.gameId,
      socket.userId,
      data.cardId,
      data.position
    );

    if (!validation.valid) {
      const response: PlacementResponse = {
        success: false,
        error: validation.error,
        errorCode: validation.errorCode
      };
      callback(response);
      return;
    }

    // Execute placement
    const result = await placementService.executePlacement(
      data.gameId,
      socket.userId,
      data.cardId,
      data.position
    );

    // Send response to requesting client
    callback({
      success: result.success,
      gameState: result.gameState,
      error: result.error,
      errorCode: result.errorCode
    });

    // Broadcast state update to all players in game
    if (result.success && result.gameState) {
      socket.to(data.gameId).emit('game:state_update', result.gameState);
      socket.emit('game:state_update', result.gameState);
    }

  } catch (error) {
    console.error('Place unit error:', error);
    callback({
      success: false,
      error: 'Internal server error',
      errorCode: 'INTERNAL_ERROR'
    });
  }
});
```

## üîå Integration Requirements

### Database Integration

#### State Persistence
```typescript
class GameStateRepository {
  async saveGameState(gameState: GameState): Promise<void> {
    const query = `
      INSERT INTO game_states (game_id, player1_id, player2_id, current_player_id, turn, phase, player1_data, player2_data)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (game_id) DO UPDATE SET
        current_player_id = $4,
        turn = $5,
        phase = $6,
        player1_data = $7,
        player2_data = $8,
        updated_at = NOW()
    `;

    await this.db.query(query, [
      gameState.gameId,
      gameState.player1Id,
      gameState.player2Id,
      gameState.currentPlayerId,
      gameState.turn,
      gameState.phase,
      JSON.stringify(gameState.player1Data),
      JSON.stringify(gameState.player2Data)
    ]);
  }

  async getGameState(gameId: string): Promise<GameState | null> {
    const query = 'SELECT * FROM game_states WHERE game_id = $1';
    const result = await this.db.query(query, [gameId]);

    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    return {
      id: row.id,
      gameId: row.game_id,
      player1Id: row.player1_id,
      player2Id: row.player2_id,
      currentPlayerId: row.current_player_id,
      turn: row.turn,
      phase: row.phase,
      player1Data: JSON.parse(row.player1_data),
      player2Data: JSON.parse(row.player2_data),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}
```

#### Action Logging
```typescript
class GameActionLogger {
  async logAction(
    gameId: string,
    playerId: string,
    actionType: string,
    actionData: any,
    stateBefore: GameState,
    stateAfter: GameState
  ): Promise<void> {
    const query = `
      INSERT INTO game_actions (game_id, player_id, action_type, action_data, game_state_before, game_state_after)
      VALUES ($1, $2, $3, $4, $5, $6)
    `;

    await this.db.query(query, [
      gameId,
      playerId,
      actionType,
      JSON.stringify(actionData),
      JSON.stringify(stateBefore),
      JSON.stringify(stateAfter)
    ]);
  }
}
```

### Card System Integration
- Integrate with Card System (Task 1.3A) for card data
- Validate card IDs against active card database
- Retrieve card stats for placement validation
- Support card abilities that affect placement rules

### Socket.io Integration
- Integrate with existing Socket.io infrastructure from Phase 2
- Use established authentication system
- Maintain connection state and error handling
- Support room-based broadcasting for game updates

## ‚úÖ Acceptance Criteria

### Placement Validation
- [ ] All faction formations properly enforced
- [ ] Resource validation prevents over-spending
- [ ] Turn validation prevents out-of-turn actions
- [ ] Position validation prevents overlapping units
- [ ] Hand validation ensures card ownership

### State Management
- [ ] Game state persisted after each placement
- [ ] State synchronization between players <100ms
- [ ] Atomic operations prevent state corruption
- [ ] Error recovery maintains game integrity

### Real-time Features
- [ ] Socket.io events handle all placement scenarios
- [ ] Error messages provide clear feedback
- [ ] State updates broadcast to all game participants
- [ ] Connection interruption doesn't break game state

### Performance Requirements
- [ ] Placement validation completes <50ms
- [ ] Database operations complete <100ms
- [ ] Memory usage remains stable during gameplay
- [ ] Concurrent placements handled correctly

## üß™ Testing Strategy

### Unit Tests
- Formation validation logic
- Resource calculation accuracy
- State transition correctness
- Error handling completeness

### Integration Tests
- Database state persistence
- Socket.io event handling
- Card system integration
- Authentication integration

### Performance Tests
- Concurrent placement handling
- Database query optimization
- Memory leak detection
- Socket.io message throughput

### Game Logic Tests
- All faction formations work correctly
- Resource management accuracy
- Turn phase transitions
- State synchronization integrity

## üì¶ Deliverables

1. **PlacementService**: Complete placement logic with validation
2. **Database Schema**: Game state and action logging tables
3. **Socket.io Handlers**: Real-time placement event handling
4. **State Management**: Persistent game state system
5. **Error Handling**: Comprehensive error responses
6. **Tests**: 90%+ test coverage for all placement logic
7. **Documentation**: API documentation and integration guides

## üöÄ Implementation Notes

### Error Handling Strategy
Provide specific error codes for frontend to display appropriate messages:
- `INVALID_POSITION`: Position not allowed by faction formation
- `INSUFFICIENT_RESOURCES`: Not enough Void Echoes for card cost
- `NOT_YOUR_TURN`: Action attempted during opponent's turn
- `INVALID_CARD`: Card not found in player's hand
- `POSITION_OCCUPIED`: Target position already has a unit

### Performance Optimizations
- Cache faction formations in memory
- Use database indexes for game state queries
- Batch multiple state updates when possible
- Implement connection pooling for database access

### Security Considerations
- Validate all user inputs server-side
- Prevent players from placing opponent's cards
- Ensure game state modifications are authorized
- Log all actions for audit and debugging

This implementation provides the robust backend foundation necessary for tactical unit placement in TCG Tactique, ensuring fair gameplay and real-time synchronization between players.