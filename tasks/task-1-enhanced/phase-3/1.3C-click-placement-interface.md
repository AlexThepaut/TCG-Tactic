# Task 1.3C: Click-Based Card Placement Interface

**Phase**: 3 - Game Mechanics
**Priority**: High
**Estimated Time**: 3-4 days
**Dependencies**: Task 1.3B (Unit Placement Backend), Phase 2 frontend infrastructure

## üéØ Objective

Create an intuitive frontend interface for tactical card placement using a two-step click-based interaction system, with clear visual feedback for placement validation and seamless integration with the backend placement system.

## üìã Requirements

### Functional Requirements

#### Hand Management System
- **Card Display**: Show player's hand with up to 7 cards
- **Card Information**: Display attack, health, cost, and abilities
- **Card Selection**: Highlight selected card with visual feedback
- **Hand Organization**: Automatic card arrangement and spacing
- **Responsive Layout**: Adapt to different screen sizes and orientations

#### Click-Based Placement Mechanics
- **Card Selection**: Click card in hand to select it (Step 1)
- **Valid Position Display**: Automatically show all valid placement positions with green highlighting
- **Click-to-Place**: Click highlighted grid position to place selected card (Step 2)
- **Selection Cancellation**: Click selected card again or click outside grid to deselect
- **Resource Validation**: Visual indication of affordable/unaffordable cards (grayed out + tooltip)
- **Touch Support**: Tap-friendly for mobile and tablet devices (minimum 44px targets)

#### Visual Feedback System
- **Selection State**: Highlighted selected card with border glow and scale effect
- **Formation Display**: Show faction-specific playable positions
- **Position Validation**: Green highlighting for valid positions when card is selected
- **Error Indication**: Shake animation + error message for invalid clicks
- **Resource Feedback**: Visual cost/resource comparison with color coding
- **Animation Transitions**: Smooth state changes and visual confirmations

#### Game Board Interface
- **Grid Visualization**: Clear 3√ó5 grid representation
- **Unit Display**: Show placed units with stats and status
- **Opponent Board**: Read-only view of opponent's board
- **Position Markers**: Clear grid position indicators
- **Faction Theming**: Visual distinction between faction areas

### Technical Requirements

#### Component Architecture
```typescript
// Main game board component
interface GameBoardProps {
  gameState: GameState;
  currentPlayer: Player;
  onCardPlace: (cardId: string, position: Position) => Promise<void>;
  onCardSelect: (cardId: string) => void;
  selectedCard?: Card;
  validPositions: Position[];
  isPlayerTurn: boolean;
}

// Hand component
interface HandProps {
  cards: Card[];
  selectedCard?: Card;
  onCardSelect: (cardId: string) => void;
  playerResources: number;
  isPlayerTurn: boolean;
}

// Grid cell component
interface GridCellProps {
  position: Position;
  unit?: PlacedCard;
  isValidPlacement: boolean;
  isPlayerSide: boolean;
  faction: Faction;
  onClick: () => void;
  isSelected: boolean;
}
```

#### Selection State Management
```typescript
// Selection state for two-step interaction
interface SelectionState {
  selectedCard: Card | null;
  validPositions: Position[];
  selectionMode: 'card' | 'target' | null;
}

interface UseCardSelectionReturn {
  selectionState: SelectionState;
  selectCard: (card: Card) => Promise<void>;
  placeCard: (position: Position) => Promise<void>;
  clearSelection: () => void;
  isPositionValid: (position: Position) => boolean;
}
```

## üìã Interaction Scenarios

### Scenario 1: Successful Card Placement
```gherkin
Given: Player has 3 cards in hand and 5 Void Echoes available
   And: Player is using Humans faction with Phalanx formation
When: Player clicks a 3-cost card in their hand
Then: Card is highlighted with border glow effect
  And: 9 valid grid positions are highlighted in green (Phalanx formation)
  And: Socket event 'game:card_selected' is emitted with cardId
When: Server responds with 'game:valid_positions' containing 9 positions
  And: Player clicks a valid highlighted position
Then: Socket event 'game:place_unit' is emitted with {cardId, position}
  And: Card animates smoothly from hand to grid
  And: Player's Void Echoes are reduced by 3
  And: Selection state is cleared
```

### Scenario 2: Invalid Placement Attempt
```gherkin
Given: Player has a card selected with valid positions displayed
When: Player clicks a grid cell that is NOT highlighted (invalid position)
Then: Shake animation appears with red flash
  And: Error message displays "Invalid placement position"
  And: Card remains selected with valid positions still highlighted
  And: No Socket event is emitted
```

### Scenario 3: Selection Cancellation
```gherkin
Given: Player has a card selected
When: Player clicks the same card again
Then: Selection visual feedback is removed (highlight cleared)
  And: Valid position highlights are cleared
  And: Socket event 'game:selection_cleared' is emitted
  And: Player can select a different card
```

### Scenario 4: Insufficient Resources
```gherkin
Given: Player has 2 Void Echoes available
When: Player attempts to select a 5-cost card
Then: Card displays "insufficient resources" feedback (grayed out + tooltip)
  And: No selection occurs
  And: No Socket event is emitted
```

### Scenario 5: Selection Switching
```gherkin
Given: Player has Card A selected with valid positions displayed
When: Player clicks Card B (different card) in their hand
Then: Card A is deselected (highlight removed)
  And: Card B is selected (new highlight applied)
  And: New valid positions for Card B are displayed
  And: Socket event 'game:card_selected' is emitted with new cardId
```

## üèóÔ∏è Technical Architecture

### React Components

#### GameBoard Component
```typescript
const GameBoard: React.FC<GameBoardProps> = ({
  gameState,
  currentPlayer,
  onCardPlace,
  selectedCard,
  validPositions,
  isPlayerTurn
}) => {
  const { selectionState, selectCard, placeCard, clearSelection } =
    useCardSelection(gameState, socket);

  return (
    <div className="game-board">
      {/* Opponent Board */}
      <div className="opponent-board">
        <PlayerGrid
          playerData={gameState.opponent}
          isInteractive={false}
          faction={gameState.opponent.faction}
        />
      </div>

      {/* Current Player Board */}
      <div className="player-board">
        <PlayerGrid
          playerData={currentPlayer}
          isInteractive={isPlayerTurn}
          faction={currentPlayer.faction}
          onCellClick={placeCard}
          validPositions={selectionState.validPositions}
          selectedPosition={null}
        />
      </div>

      {/* Player Hand */}
      <Hand
        cards={currentPlayer.hand}
        selectedCard={selectionState.selectedCard}
        onCardSelect={selectCard}
        playerResources={currentPlayer.resources}
        isPlayerTurn={isPlayerTurn}
      />
    </div>
  );
};
```

#### Hand Component
```typescript
const Hand: React.FC<HandProps> = ({
  cards,
  selectedCard,
  onCardSelect,
  playerResources,
  isPlayerTurn
}) => {
  return (
    <div className="hand-container">
      <div className="hand-cards">
        {cards.map((card, index) => (
          <HandCard
            key={card.id}
            card={card}
            index={index}
            isSelected={selectedCard?.id === card.id}
            canAfford={card.cost <= playerResources}
            isClickable={isPlayerTurn && card.cost <= playerResources}
            onClick={() => onCardSelect(card)}
          />
        ))}
      </div>

      <div className="resource-display">
        <span className="resource-count">{playerResources}</span>
        <span className="resource-label">Void Echoes</span>
      </div>
    </div>
  );
};
```

#### Grid Cell Component
```typescript
const GridCell: React.FC<GridCellProps> = ({
  position,
  unit,
  isValidPlacement,
  isPlayerSide,
  faction,
  onClick,
  isSelected
}) => {
  const [isHovered, setIsHovered] = useState(false);

  const handleClick = () => {
    if (isValidPlacement) {
      onClick();
    }
  };

  return (
    <div
      className={`grid-cell ${getGridCellClasses()}`}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      {unit && <UnitCard unit={unit} />}
      {isValidPlacement && isHovered && <PlacementPreview />}
    </div>
  );

  function getGridCellClasses() {
    const classes = [];

    if (isPlayerSide) classes.push('player-side');
    else classes.push('opponent-side');

    classes.push(`faction-${faction}`);

    if (isValidPlacement) classes.push('valid-placement');
    if (isHovered && isValidPlacement) classes.push('hover-highlight');
    if (isSelected) classes.push('selected');
    if (unit) classes.push('occupied');

    return classes.join(' ');
  }
};
```

### Custom Hooks

#### useCardSelection Hook
```typescript
const useCardSelection = (gameState: GameState, socket: Socket) => {
  const [selectionState, setSelectionState] = useState<SelectionState>({
    selectedCard: null,
    validPositions: [],
    selectionMode: null
  });

  const selectCard = async (card: Card) => {
    // Check if clicking already selected card (deselect)
    if (selectionState.selectedCard?.id === card.id) {
      clearSelection();
      return;
    }

    // Emit card selection to server for validation
    socket.emit('game:card_selected',
      { gameId: gameState.id, cardId: card.id },
      (response: ValidPositionsResponse) => {
        if (response.success) {
          setSelectionState({
            selectedCard: card,
            validPositions: response.validPositions,
            selectionMode: 'target'
          });
        } else {
          console.error('Card selection failed:', response.error);
        }
      }
    );
  };

  const placeCard = async (position: Position) => {
    if (!selectionState.selectedCard) return;

    // Validate position is in valid positions
    if (!isPositionValid(position)) {
      // Show error feedback
      showErrorFeedback('Invalid placement position');
      return;
    }

    // Emit placement to server
    socket.emit('game:place_unit',
      {
        gameId: gameState.id,
        cardId: selectionState.selectedCard.id,
        position,
        handIndex: getHandIndex(selectionState.selectedCard.id)
      },
      (response: PlacementResponse) => {
        if (response.success) {
          clearSelection();
        } else {
          showErrorFeedback(response.error || 'Placement failed');
        }
      }
    );
  };

  const clearSelection = () => {
    socket.emit('game:selection_cleared', { gameId: gameState.id });
    setSelectionState({
      selectedCard: null,
      validPositions: [],
      selectionMode: null
    });
  };

  const isPositionValid = (position: Position): boolean => {
    return selectionState.validPositions.some(pos =>
      pos.x === position.x && pos.y === position.y
    );
  };

  return {
    selectionState,
    selectCard,
    placeCard,
    clearSelection,
    isPositionValid
  };
};
```

## üé® Visual Design

### CSS Styling Structure
```css
/* Game Board Layout */
.game-board {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(135deg, #1a1a2e, #16213e);
}

.opponent-board {
  flex: 1;
  padding: 1rem;
  transform: rotate(180deg); /* Opponent board upside down */
}

.player-board {
  flex: 1;
  padding: 1rem;
}

/* Grid Styling */
.player-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

.grid-cell {
  aspect-ratio: 1;
  border: 2px solid transparent;
  border-radius: 8px;
  position: relative;
  transition: all 0.2s ease;
  cursor: pointer;
}

/* Faction-specific grid styling */
.grid-cell.faction-humans {
  background: rgba(59, 130, 246, 0.1);
  border-color: rgba(59, 130, 246, 0.3);
}

.grid-cell.faction-aliens {
  background: rgba(34, 197, 94, 0.1);
  border-color: rgba(34, 197, 94, 0.3);
}

.grid-cell.faction-robots {
  background: rgba(239, 68, 68, 0.1);
  border-color: rgba(239, 68, 68, 0.3);
}

/* Click-based interaction states */
.grid-cell.valid-placement {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.2);
  cursor: pointer;
}

.grid-cell.hover-highlight {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.4);
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
}

.grid-cell.selected {
  border-color: #3b82f6;
  background: rgba(59, 130, 246, 0.3);
}

.grid-cell.occupied {
  cursor: default;
}

/* Hand Styling */
.hand-container {
  padding: 1rem;
  background: rgba(0, 0, 0, 0.3);
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.hand-cards {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

/* Card Styling */
.hand-card {
  width: 80px;
  height: 112px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  min-width: 44px;  /* Mobile touch target */
  min-height: 44px;
}

.hand-card:hover {
  transform: translateY(-8px) scale(1.05);
}

.hand-card.selected {
  transform: translateY(-12px) scale(1.1);
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
  border: 3px solid #3b82f6;
}

.hand-card.unaffordable {
  opacity: 0.4;
  cursor: not-allowed;
  filter: grayscale(70%);
}

.hand-card.unaffordable:hover {
  transform: none;
}

/* Animations */
@keyframes cardPlace {
  0% {
    transform: scale(1.2) rotate(5deg);
    opacity: 0.8;
  }
  100% {
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

.card-placed {
  animation: cardPlace 0.3s ease-out;
}

@keyframes shakeError {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.error-shake {
  animation: shakeError 0.3s ease-in-out;
}

/* Selection glow effect */
@keyframes selectionGlow {
  0%, 100% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.6); }
  50% { box-shadow: 0 0 25px rgba(59, 130, 246, 0.9); }
}

.hand-card.selected {
  animation: selectionGlow 1.5s infinite;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .game-board {
    padding: 0.5rem;
  }

  .hand-card {
    width: 60px;
    height: 84px;
    min-width: 44px;
    min-height: 44px;
  }

  .player-grid {
    max-width: 100%;
    gap: 0.25rem;
  }

  .grid-cell {
    min-width: 44px;  /* Touch-friendly */
    min-height: 44px;
  }
}
```

## üîå Integration Requirements

### Backend Integration
- Connect to placement backend (Task 1.3B) via Socket.io
- Handle two-step interaction with new events:
  1. `game:card_selected` ‚Üí receive `game:valid_positions`
  2. `game:place_unit` ‚Üí receive placement confirmation
- Display server-side error messages
- Sync with real-time game state updates

### Socket.io Integration
```typescript
const useGamePlacement = () => {
  const socket = useSocket();

  const selectCard = async (cardId: string): Promise<Position[]> => {
    return new Promise((resolve, reject) => {
      socket.emit('game:card_selected', {
        cardId
      }, (response: ValidPositionsResponse) => {
        if (response.success) {
          resolve(response.validPositions);
        } else {
          reject(new Error(response.error));
        }
      });
    });
  };

  const placeCard = async (cardId: string, position: Position): Promise<void> => {
    return new Promise((resolve, reject) => {
      socket.emit('game:place_unit', {
        cardId,
        position,
        handIndex: getHandIndex(cardId)
      }, (response: PlacementResponse) => {
        if (response.success) {
          resolve();
        } else {
          reject(new Error(response.error));
        }
      });
    });
  };

  const clearSelection = () => {
    socket.emit('game:selection_cleared', {});
  };

  return { selectCard, placeCard, clearSelection };
};
```

### State Management
- Integrate with global game state from useGameSocket
- Update local state optimistically with server confirmation
- Handle state rollback on placement failures
- Maintain UI state consistency during network latency

## ‚úÖ Acceptance Criteria

### Click-Based Functionality
- [ ] Smooth card selection on desktop and mobile
- [ ] Visual feedback for valid/invalid positions
- [ ] Two-step interaction: select card ‚Üí click position
- [ ] Touch-friendly mobile interaction (44px minimum targets)
- [ ] Proper error handling for failed placements

### Visual Design
- [ ] Clear faction-specific grid styling
- [ ] Responsive layout for all screen sizes
- [ ] Smooth animations and transitions
- [ ] Professional UI polish
- [ ] Accessibility features (keyboard navigation, screen readers)

### Integration
- [ ] Real-time synchronization with backend
- [ ] Two-step Socket.io event flow working correctly
- [ ] Error messages displayed to user
- [ ] State consistency maintained
- [ ] Performance >60fps during interactions

### User Experience
- [ ] Intuitive click-to-select, click-to-place mechanics
- [ ] Clear visual feedback for all states
- [ ] Responsive design works on mobile landscape
- [ ] Loading states and error handling
- [ ] Selection can be cancelled easily

## üß™ Testing Strategy

### Component Tests
- Click selection event handling
- Card selection state management
- Valid position calculation and display
- Selection cancellation flows
- Error state handling (insufficient resources, invalid position)
- Click outside to deselect functionality

### Integration Tests
- Socket.io event sequence: card_selected ‚Üí valid_positions ‚Üí place_unit
- Server-side position validation
- State synchronization between players
- Error scenarios and recovery
- Selection state persistence

### E2E Tests
- Complete click-based placement workflow
- Mobile tap interactions (44px minimum targets)
- Cross-browser compatibility
- Performance under load
- Multi-player simultaneous interactions

### Accessibility Tests
- Keyboard navigation for card selection
- Screen reader announcements for state changes
- Color contrast compliance
- Focus management during selection
- ARIA labels for interactive elements

## üì¶ Deliverables

1. **GameBoard Component**: Complete click-based placement interface
2. **Hand Component**: Interactive card hand with selection state
3. **Grid Components**: Faction-specific game board with click handlers
4. **Custom Hooks**: useCardSelection hook with Socket integration
5. **Styling**: Complete CSS with responsive design and animations
6. **Integration**: Socket.io two-step event flow implementation
7. **Tests**: Comprehensive test suite for click-based interactions
8. **Documentation**: Component API and integration guides

## üöÄ Implementation Notes

### Performance Optimizations
- Use React.memo for grid cells to prevent unnecessary re-renders
- Debounce rapid click events (200ms)
- Optimize CSS animations for 60fps
- Cache valid position calculations client-side

### Accessibility Considerations
- ARIA labels for all interactive elements
- Keyboard shortcuts for card selection (1-7 keys)
- High contrast mode support
- Screen reader announcements for game actions
- Focus management during state changes

### Mobile Considerations
- Touch-friendly targets (minimum 44√ó44px)
- Haptic feedback for touch interactions (if available)
- Prevent accidental clicks during scrolling
- Optimize for landscape orientation
- Handle iOS Safari quirks

### Error Handling Strategy
- Network timeout on `game:valid_positions` (3s timeout)
- Show loading indicator during server validation
- Clear error messages for all failure scenarios
- Automatic selection clearing on critical errors
- Retry mechanism for network failures

This implementation creates an intuitive and responsive click-based interface that makes tactical card placement engaging and accessible across all devices, with a clear two-step interaction pattern that prevents accidental placements.