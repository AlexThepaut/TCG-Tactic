# Task 1.3F: Turn Management System

**Phase**: 3 - Game Mechanics
**Priority**: Critical
**Estimated Time**: 3-4 days
**Dependencies**: All previous Phase 3 tasks (1.3A-1.3E), existing Socket.io infrastructure

## üéØ Objective

Implement comprehensive turn-based gameplay structure with resource management, card draw mechanics, phase transitions, and victory condition detection to create a complete game flow system.

## üìã Requirements

### Functional Requirements

#### Turn Structure System
- **Three-Phase Turns**: Resources ‚Üí Draw ‚Üí Actions progression
- **Phase Validation**: Ensure actions only occur in appropriate phases
- **Automatic Transitions**: Smooth progression between phases
- **Turn Timer**: Optional time limits for each phase/turn
- **Phase Skip**: Allow players to skip phases when appropriate

#### Resource Management (Void Echoes)
- **Starting Resources**: Begin with 1 Void Echo
- **Resource Growth**: +1 Void Echo per turn (maximum 10)
- **Resource Spending**: Deduct cost when placing units
- **Resource Display**: Real-time resource tracking
- **Resource Validation**: Prevent overspending before actions

#### Card Draw System
- **Automatic Draw**: Draw 1 card at start of draw phase
- **Hand Limit**: Maximum 7 cards in hand (enforce during draw)
- **Deck Tracking**: Monitor remaining cards in deck
- **Deck Empty**: Handle when player runs out of cards
- **Card Overflow**: Handle drawing when hand is full

#### Victory Conditions
- **Primary Victory**: Opponent's deck is empty (basic implementation)
- **Quest System**: Framework for future faction-specific victory conditions
- **Game End Detection**: Automatic game conclusion when victory achieved
- **Winner Declaration**: Clear winner announcement and game state update

### Technical Requirements

#### Turn Management Schema
```sql
-- Turn management state
ALTER TABLE game_states ADD COLUMN phase_data JSONB DEFAULT '{
  "currentPhase": "resources",
  "phaseStartTime": null,
  "turnStartTime": null,
  "phaseTimeLimit": null,
  "turnTimeLimit": null,
  "actionsThisTurn": []
}';

-- Turn history tracking
CREATE TABLE turn_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID NOT NULL REFERENCES games(id),
    turn_number INTEGER NOT NULL,
    player_id UUID NOT NULL,
    phase VARCHAR(20) NOT NULL,
    action_type VARCHAR(50) NOT NULL,
    action_data JSONB,
    timestamp TIMESTAMP DEFAULT NOW()
);
```

#### Turn State Management
```typescript
interface TurnPhaseData {
  currentPhase: 'resources' | 'draw' | 'actions';
  phaseStartTime: Date | null;
  turnStartTime: Date | null;
  phaseTimeLimit: number | null; // seconds
  turnTimeLimit: number | null; // seconds
  actionsThisTurn: TurnAction[];
}

interface TurnAction {
  type: 'place_unit' | 'attack' | 'cast_spell' | 'end_turn';
  timestamp: Date;
  data: any;
}

interface VictoryCondition {
  id: string;
  type: 'deck_empty' | 'quest_complete' | 'elimination';
  description: string;
  checkFunction: (gameState: GameState) => boolean;
  winnerFunction: (gameState: GameState) => string | null;
}
```

## üèóÔ∏è Technical Architecture

### Turn Management Service

#### TurnManager Implementation
```typescript
class TurnManager {
  private gameStateService: GameStateService;
  private victoryService: VictoryService;
  private logger: GameLogger;

  async startTurn(gameId: string): Promise<GameState> {
    const gameState = await this.gameStateService.getGameState(gameId);
    if (!gameState) throw new Error('Game not found');

    // Increment turn counter
    gameState.turn += 1;

    // Switch current player
    gameState.currentPlayerId = this.getNextPlayer(gameState);

    // Start resources phase
    gameState.phase = 'resources';
    gameState.phaseData = {
      currentPhase: 'resources',
      phaseStartTime: new Date(),
      turnStartTime: new Date(),
      phaseTimeLimit: null,
      turnTimeLimit: null,
      actionsThisTurn: []
    };

    // Apply resource phase logic
    await this.executeResourcesPhase(gameState);

    await this.gameStateService.saveGameState(gameState);
    return gameState;
  }

  async executeResourcesPhase(gameState: GameState): Promise<void> {
    const currentPlayer = this.getCurrentPlayerData(gameState);

    // Increase Void Echoes (+1 per turn, max 10)
    currentPlayer.maxResources = Math.min(10, currentPlayer.maxResources + 1);
    currentPlayer.resources = currentPlayer.maxResources;

    // Log resource gain
    this.logger.logTurnAction(gameState.gameId, {
      type: 'resource_gain',
      playerId: gameState.currentPlayerId,
      data: {
        newResources: currentPlayer.resources,
        maxResources: currentPlayer.maxResources
      }
    });

    // Auto-transition to draw phase
    setTimeout(() => {
      this.transitionToPhase(gameState.gameId, 'draw');
    }, 1000); // 1 second delay for visual feedback
  }

  async transitionToPhase(gameId: string, newPhase: 'resources' | 'draw' | 'actions'): Promise<GameState> {
    const gameState = await this.gameStateService.getGameState(gameId);
    if (!gameState) throw new Error('Game not found');

    const previousPhase = gameState.phase;
    gameState.phase = newPhase;
    gameState.phaseData.currentPhase = newPhase;
    gameState.phaseData.phaseStartTime = new Date();

    // Execute phase-specific logic
    switch (newPhase) {
      case 'draw':
        await this.executeDrawPhase(gameState);
        break;
      case 'actions':
        await this.executeActionsPhase(gameState);
        break;
    }

    await this.gameStateService.saveGameState(gameState);

    // Broadcast phase change
    this.broadcastPhaseChange(gameId, previousPhase, newPhase, gameState);

    return gameState;
  }

  async executeDrawPhase(gameState: GameState): Promise<void> {
    const currentPlayer = this.getCurrentPlayerData(gameState);

    // Check if deck is empty (victory condition)
    if (currentPlayer.deck.length === 0) {
      await this.handleVictory(gameState, this.getOpponentId(gameState), 'deck_empty');
      return;
    }

    // Check hand limit
    if (currentPlayer.hand.length >= 7) {
      // Hand is full, skip draw but still transition
      this.logger.logTurnAction(gameState.gameId, {
        type: 'draw_skipped',
        playerId: gameState.currentPlayerId,
        data: { reason: 'hand_full' }
      });
    } else {
      // Draw card from deck
      const drawnCard = currentPlayer.deck.shift()!;
      currentPlayer.hand.push(drawnCard);

      this.logger.logTurnAction(gameState.gameId, {
        type: 'card_drawn',
        playerId: gameState.currentPlayerId,
        data: { cardId: drawnCard.id }
      });
    }

    // Auto-transition to actions phase
    setTimeout(() => {
      this.transitionToPhase(gameState.gameId, 'actions');
    }, 1500); // 1.5 seconds for draw animation
  }

  async executeActionsPhase(gameState: GameState): Promise<void> {
    // Actions phase is player-driven, no automatic transitions
    this.logger.logTurnAction(gameState.gameId, {
      type: 'actions_phase_started',
      playerId: gameState.currentPlayerId,
      data: {}
    });
  }

  async endTurn(gameId: string, playerId: string): Promise<GameState> {
    const gameState = await this.gameStateService.getGameState(gameId);
    if (!gameState) throw new Error('Game not found');

    // Validate turn end request
    if (gameState.currentPlayerId !== playerId) {
      throw new Error('Not your turn');
    }

    if (gameState.phase !== 'actions') {
      throw new Error('Can only end turn during actions phase');
    }

    // Check for victory conditions before ending turn
    const victoryResult = await this.victoryService.checkVictoryConditions(gameState);
    if (victoryResult.hasWinner) {
      await this.handleVictory(gameState, victoryResult.winner!, victoryResult.condition!);
      return gameState;
    }

    // Log turn end
    this.logger.logTurnAction(gameState.gameId, {
      type: 'turn_ended',
      playerId: gameState.currentPlayerId,
      data: {
        actionsThisTurn: gameState.phaseData.actionsThisTurn.length
      }
    });

    // Start next turn
    return await this.startTurn(gameId);
  }

  private async handleVictory(gameState: GameState, winnerId: string, condition: string): Promise<void> {
    gameState.gameOver = true;
    gameState.winner = winnerId;

    await this.gameStateService.saveGameState(gameState);

    // Broadcast game end
    this.broadcastGameEnd(gameState.gameId, winnerId, condition);

    // Log victory
    this.logger.logTurnAction(gameState.gameId, {
      type: 'game_victory',
      playerId: winnerId,
      data: { condition, turn: gameState.turn }
    });
  }
}
```

### Victory Condition System

#### VictoryService Implementation
```typescript
class VictoryService {
  private victoryConditions: Map<string, VictoryCondition> = new Map();

  constructor() {
    this.initializeVictoryConditions();
  }

  private initializeVictoryConditions(): void {
    // Deck Empty Victory
    this.victoryConditions.set('deck_empty', {
      id: 'deck_empty',
      type: 'deck_empty',
      description: 'Opponent runs out of cards',
      checkFunction: (gameState: GameState) => {
        const player1Deck = gameState.player1Data.deck.length;
        const player2Deck = gameState.player2Data.deck.length;
        return player1Deck === 0 || player2Deck === 0;
      },
      winnerFunction: (gameState: GameState) => {
        if (gameState.player1Data.deck.length === 0) {
          return gameState.player2Id;
        }
        if (gameState.player2Data.deck.length === 0) {
          return gameState.player1Id;
        }
        return null;
      }
    });

    // Future: Quest-based victories
    // this.victoryConditions.set('quest_complete', { ... });
  }

  async checkVictoryConditions(gameState: GameState): Promise<VictoryResult> {
    for (const condition of this.victoryConditions.values()) {
      if (condition.checkFunction(gameState)) {
        const winner = condition.winnerFunction(gameState);
        if (winner) {
          return {
            hasWinner: true,
            winner,
            condition: condition.id,
            description: condition.description
          };
        }
      }
    }

    return { hasWinner: false };
  }
}

interface VictoryResult {
  hasWinner: boolean;
  winner?: string;
  condition?: string;
  description?: string;
}
```

## üîå Socket.io Integration

### Turn Management Events
```typescript
// Client to Server Events
interface ClientToServerEvents {
  'game:end_turn': (gameId: string, callback: (response: EndTurnResponse) => void) => void;
  'game:skip_phase': (gameId: string, callback: (response: PhaseResponse) => void) => void;
}

interface EndTurnResponse {
  success: boolean;
  gameState?: GameState;
  error?: string;
  errorCode?: string;
}

// Server to Client Events
interface ServerToClientEvents {
  'game:turn_started': (playerId: string, turn: number, gameState: GameState) => void;
  'game:phase_changed': (phase: string, gameState: GameState) => void;
  'game:resource_gained': (playerId: string, newResources: number) => void;
  'game:card_drawn': (playerId: string, cardId?: string) => void; // cardId hidden for opponent
  'game:victory': (winnerId: string, condition: string, gameState: GameState) => void;
}
```

### Socket Event Handlers
```typescript
// End turn handler
socket.on('game:end_turn', async (gameId: string, callback) => {
  try {
    const newGameState = await turnManager.endTurn(gameId, socket.userId);

    callback({
      success: true,
      gameState: newGameState
    });

    // Broadcast turn change
    socket.to(gameId).emit('game:turn_started',
      newGameState.currentPlayerId,
      newGameState.turn,
      newGameState
    );
    socket.emit('game:turn_started',
      newGameState.currentPlayerId,
      newGameState.turn,
      newGameState
    );

  } catch (error) {
    callback({
      success: false,
      error: error.message,
      errorCode: 'TURN_END_FAILED'
    });
  }
});

// Phase change handler
socket.on('game:skip_phase', async (gameId: string, callback) => {
  try {
    const gameState = await gameStateService.getGameState(gameId);
    if (!gameState || gameState.currentPlayerId !== socket.userId) {
      throw new Error('Invalid phase skip request');
    }

    let nextPhase: string;
    switch (gameState.phase) {
      case 'resources':
        nextPhase = 'draw';
        break;
      case 'draw':
        nextPhase = 'actions';
        break;
      default:
        throw new Error('Cannot skip actions phase');
    }

    const newGameState = await turnManager.transitionToPhase(gameId, nextPhase as any);

    callback({
      success: true,
      gameState: newGameState
    });

  } catch (error) {
    callback({
      success: false,
      error: error.message,
      errorCode: 'PHASE_SKIP_FAILED'
    });
  }
});
```

## üé® Frontend Integration

### Turn Display Components
```typescript
// Turn indicator component
interface TurnIndicatorProps {
  gameState: GameState;
  currentUserId: string;
}

const TurnIndicator: React.FC<TurnIndicatorProps> = ({ gameState, currentUserId }) => {
  const isMyTurn = gameState.currentPlayerId === currentUserId;
  const currentPhase = gameState.phase;

  return (
    <div className={`turn-indicator ${isMyTurn ? 'my-turn' : 'opponent-turn'}`}>
      <div className="turn-info">
        <span className="turn-number">Turn {gameState.turn}</span>
        <span className="current-player">
          {isMyTurn ? 'Your Turn' : "Opponent's Turn"}
        </span>
      </div>

      <div className="phase-indicator">
        <div className={`phase ${currentPhase === 'resources' ? 'active' : 'completed'}`}>
          Resources
        </div>
        <div className={`phase ${currentPhase === 'draw' ? 'active' : currentPhase === 'actions' ? 'completed' : ''}`}>
          Draw
        </div>
        <div className={`phase ${currentPhase === 'actions' ? 'active' : ''}`}>
          Actions
        </div>
      </div>

      {isMyTurn && currentPhase === 'actions' && (
        <button onClick={handleEndTurn} className="end-turn-button">
          End Turn
        </button>
      )}
    </div>
  );
};

// Resource display component
interface ResourceDisplayProps {
  resources: number;
  maxResources: number;
  isCurrentPlayer: boolean;
}

const ResourceDisplay: React.FC<ResourceDisplayProps> = ({
  resources,
  maxResources,
  isCurrentPlayer
}) => {
  return (
    <div className="resource-display">
      <div className="resource-counter">
        <span className="current">{resources}</span>
        <span className="separator">/</span>
        <span className="max">{maxResources}</span>
      </div>
      <div className="resource-label">Void Echoes</div>

      {/* Resource visualization */}
      <div className="resource-orbs">
        {Array.from({ length: 10 }, (_, i) => (
          <div
            key={i}
            className={`resource-orb ${
              i < resources ? 'filled' :
              i < maxResources ? 'available' : 'locked'
            }`}
          />
        ))}
      </div>
    </div>
  );
};
```

### Turn Management Hooks
```typescript
const useTurnManagement = (gameId: string) => {
  const socket = useSocket();
  const [turnState, setTurnState] = useState<TurnState | null>(null);

  const endTurn = async (): Promise<void> => {
    return new Promise((resolve, reject) => {
      socket.emit('game:end_turn', gameId, (response: EndTurnResponse) => {
        if (response.success) {
          resolve();
        } else {
          reject(new Error(response.error));
        }
      });
    });
  };

  const skipPhase = async (): Promise<void> => {
    return new Promise((resolve, reject) => {
      socket.emit('game:skip_phase', gameId, (response: PhaseResponse) => {
        if (response.success) {
          resolve();
        } else {
          reject(new Error(response.error));
        }
      });
    });
  };

  useEffect(() => {
    socket.on('game:turn_started', (playerId: string, turn: number, gameState: GameState) => {
      setTurnState({
        currentPlayer: playerId,
        turn,
        phase: gameState.phase,
        gameState
      });
    });

    socket.on('game:phase_changed', (phase: string, gameState: GameState) => {
      setTurnState(prev => prev ? {
        ...prev,
        phase: phase as any,
        gameState
      } : null);
    });

    socket.on('game:victory', (winnerId: string, condition: string, gameState: GameState) => {
      // Handle victory
      setTurnState(prev => prev ? {
        ...prev,
        gameState: { ...gameState, gameOver: true, winner: winnerId }
      } : null);
    });

    return () => {
      socket.off('game:turn_started');
      socket.off('game:phase_changed');
      socket.off('game:victory');
    };
  }, [socket]);

  return {
    turnState,
    endTurn,
    skipPhase
  };
};
```

## ‚úÖ Acceptance Criteria

### Turn Flow
- [ ] Smooth progression through all three phases
- [ ] Automatic phase transitions with appropriate delays
- [ ] Manual turn ending during actions phase
- [ ] Turn validation prevents out-of-turn actions
- [ ] Phase validation prevents wrong-phase actions

### Resource Management
- [ ] Void Echoes increase correctly (+1 per turn, max 10)
- [ ] Resource spending validation prevents overspending
- [ ] Real-time resource display updates
- [ ] Resource state synchronization between players

### Card Draw System
- [ ] Automatic card draw during draw phase
- [ ] Hand limit enforcement (max 7 cards)
- [ ] Deck empty detection triggers victory
- [ ] Draw animations and visual feedback

### Victory Conditions
- [ ] Deck empty victory detection works correctly
- [ ] Game end state properly set and synchronized
- [ ] Victory announcement clear and immediate
- [ ] Framework ready for future quest-based victories

## üß™ Testing Strategy

### Unit Tests
- Turn phase transitions
- Resource calculation accuracy
- Victory condition detection
- Turn validation logic

### Integration Tests
- Socket.io turn event handling
- Database state persistence
- Real-time synchronization
- Multi-player turn coordination

### Game Flow Tests
- Complete game scenarios
- Edge cases (empty deck, full hand)
- Victory condition scenarios
- Turn timing and transitions

### Performance Tests
- Turn transition speed
- Database query optimization
- Memory usage during long games
- Concurrent game handling

## üì¶ Deliverables

1. **TurnManager Service**: Complete turn management system
2. **VictoryService**: Victory condition detection and handling
3. **Socket.io Integration**: Real-time turn and phase events
4. **Frontend Components**: Turn display and resource management
5. **Database Schema**: Turn history and phase tracking
6. **Tests**: Comprehensive turn management test suite
7. **Documentation**: Turn system and victory condition guides

## üöÄ Implementation Notes

### Turn Timing
- Phase transitions use appropriate delays for visual feedback
- Optional turn timers can be added for competitive play
- Turn validation prevents race conditions

### Victory Extension
- Framework designed for easy addition of quest-based victories
- Victory conditions are modular and extensible
- Support for complex multi-condition victories

### Performance Optimization
- Efficient turn state queries
- Minimal database updates per turn
- Cached victory condition checks

This turn management system provides the complete game flow structure necessary for engaging tactical gameplay in TCG Tactique.