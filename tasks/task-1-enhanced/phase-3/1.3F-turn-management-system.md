# Task 1.3F: Turn Management System (Completion & Polish)

**Phase**: 3 - Game Mechanics
**Priority**: High (Reduced from Critical - 92% Complete)
**Estimated Time**: 1-2 days (Reduced from 3-4 days)
**Dependencies**: 1.3D (Combat Logic Engine) - Critical blocker, existing Socket.io infrastructure

## üéØ Objective

Complete and polish the existing turn management system by addressing the remaining 8% of functionality gaps, integrating with combat logic, and ensuring robust production-ready operation.

## üìã Requirements

### ‚úÖ Already Implemented (92% Complete)
The existing `gameMechanicsService.ts` already provides:
- ‚úÖ Complete three-phase turn structure (resources ‚Üí draw ‚Üí actions)
- ‚úÖ Automatic resource management with Void Echoes (1-10 scaling)
- ‚úÖ Card draw mechanics with hand limits (max 7 cards)
- ‚úÖ Victory condition detection (quest completion, deck empty, timeout)
- ‚úÖ Turn switching and phase progression logic
- ‚úÖ Game action system with comprehensive logging
- ‚úÖ Faction passive ability processing
- ‚úÖ Combat resolution integration hooks

### üîß Completion Requirements (Remaining 8%)

#### Integration & Polish Gaps
- **Combat Logic Integration**: Connect with Task 1.3D combat engine for attack resolution
- **Socket.io Event Handlers**: Complete turn event broadcasting and client synchronization
- **Frontend Turn Display**: Implement turn indicator and phase visualization components
- **Error Recovery**: Add robust error handling for network failures and state inconsistencies
- **Performance Optimization**: Cache turn state queries and optimize database operations

#### Missing Edge Cases
- **Simultaneous Actions**: Handle race conditions during turn transitions
- **Reconnection Handling**: Restore turn state for reconnecting players
- **Turn Timer Integration**: Add optional time limits with automatic turn ending
- **Animation Coordination**: Sync phase transitions with UI animations

### Technical Requirements

#### Database Schema Completion
```sql
-- ‚úÖ Already exists: Core game state and turn tracking
-- üîß Add: Performance optimizations for turn queries

-- Add indexes for turn management performance
CREATE INDEX IF NOT EXISTS idx_games_current_player ON games(current_player, status);
CREATE INDEX IF NOT EXISTS idx_game_actions_game_turn ON game_actions(game_id, turn, timestamp);
CREATE INDEX IF NOT EXISTS idx_games_status_updated ON games(status, updated_at);

-- Add turn timer fields if not present
ALTER TABLE games ADD COLUMN IF NOT EXISTS turn_time_limit INTEGER DEFAULT 300; -- 5 minutes
ALTER TABLE games ADD COLUMN IF NOT EXISTS turn_deadline TIMESTAMP;
```

#### Completion-Focused Technical Extensions
```typescript
// ‚úÖ Core interfaces already exist in types/gameState.ts

// üîß Add: Turn timer service integration
interface TurnTimerService {
  startTurnTimer(gameId: string, playerId: number, duration: number): void;
  pauseTurnTimer(gameId: string): void;
  resumeTurnTimer(gameId: string): void;
  getRemainingTime(gameId: string): number;
  onTimeExpired: (gameId: string) => Promise<void>;
}

// üîß Add: Enhanced error handling
interface TurnManagementError {
  type: 'network_failure' | 'state_conflict' | 'timeout' | 'invalid_action';
  gameId: string;
  playerId: number;
  turn: number;
  phase: GamePhase;
  recovery: () => Promise<GameState>;
}

// üîß Add: State synchronization
interface TurnSyncStatus {
  isInSync: boolean;
  lastSyncAt: Date;
  pendingActions: GameAction[];
  conflictResolution?: 'server_wins' | 'client_rollback' | 'merge_states';
}
```

## üèóÔ∏è Completion Architecture

### ‚úÖ Existing Foundation
The current `GameMechanicsService` in `backend/src/services/gameMechanicsService.ts` already provides:
- Complete turn progression logic (`progressPhase`, `handleResourcePhase`, `handleDrawPhase`)
- Action execution system (`executeAction`, `executeEndTurn`)
- Victory condition checking (`checkWinConditions`)
- Faction passive ability processing
- Combat integration hooks

### üîß Required Completions

#### 1. Socket.io Event Handler Enhancement
```typescript
// Existing gameHandlers.ts needs these additions:
class TurnEventHandlers {
  async handleEndTurn(socket: Socket, gameId: string): Promise<void> {
    try {
      const gameState = await gameStateService.getGameState(gameId);
      if (!gameState || !this.validateTurnEnd(gameState, socket.userId)) {
        return socket.emit('turn:error', { message: 'Invalid turn end' });
      }

      const endTurnAction: GameAction = {
        id: generateId(),
        gameId: parseInt(gameId),
        playerId: socket.userId,
        actionType: 'end_turn',
        turn: gameState.turn,
        phase: gameState.phase,
        timestamp: new Date(),
        actionData: {}
      };

      const result = gameMechanicsService.executeAction(gameState, endTurnAction);
      await gameStateService.saveGameState(result.newState);

      // Broadcast turn changes
      io.to(gameId).emit('turn:updated', {
        currentPlayer: result.newState.currentPlayer,
        turn: result.newState.turn,
        phase: result.newState.phase
      });

      // Check for game end
      if (result.newState.gameOver) {
        io.to(gameId).emit('game:ended', {
          winner: result.newState.winner,
          condition: result.newState.winCondition
        });
      }
    } catch (error) {
      socket.emit('turn:error', { message: error.message });
    }
  }
}

#### 2. Turn Timer Service (New Component)
```typescript
export class TurnTimerService {
  private timers: Map<string, NodeJS.Timeout> = new Map();
  private gameTimeouts: Map<string, number> = new Map(); // gameId -> deadline timestamp

  startTurnTimer(gameId: string, playerId: number, durationSeconds: number): void {
    this.clearTimer(gameId); // Clear existing timer

    const deadline = Date.now() + (durationSeconds * 1000);
    this.gameTimeouts.set(gameId, deadline);

    const timer = setTimeout(async () => {
      await this.handleTurnTimeout(gameId, playerId);
    }, durationSeconds * 1000);

    this.timers.set(gameId, timer);
  }

  private async handleTurnTimeout(gameId: string, playerId: number): Promise<void> {
    try {
      // Force end turn for timed-out player
      const endTurnAction: GameAction = {
        id: generateId(),
        gameId: parseInt(gameId),
        playerId,
        actionType: 'end_turn',
        turn: 0, // Will be set from current game state
        phase: 'actions',
        timestamp: new Date(),
        actionData: { autoEnded: true, reason: 'timeout' }
      };

      const gameState = await gameStateService.getGameState(gameId);
      if (gameState && !gameState.gameOver) {
        const result = gameMechanicsService.executeAction(gameState, endTurnAction);
        await gameStateService.saveGameState(result.newState);

        // Notify players of timeout
        io.to(gameId).emit('turn:timeout', { playerId, newState: result.newState });
      }
    } catch (error) {
      logger.error('Turn timeout handling failed', { gameId, playerId, error });
    } finally {
      this.clearTimer(gameId);
    }
  }
}
```

#### 3. Combat Integration Bridge
```typescript
// Integration with Task 1.3D Combat Engine
export class TurnCombatBridge {
  async processCombatAction(gameState: GameState, combatAction: GameAction): Promise<GameActionResult[]> {
    // This bridges the existing gameMechanicsService with the new combat engine
    const combatResults = await combatEngineService.resolveCombat(
      gameState,
      combatAction.actionData as AttackActionData
    );

    // Update turn-related state after combat
    const attackingPlayer = getPlayerState(gameState, combatAction.playerId);
    if (attackingPlayer) {
      attackingPlayer.actionsThisTurn.push(combatAction);
    }

    return combatResults;
  }
}

## üîå Socket.io Integration Completion

### Additional Event Types Required
```typescript
// üîß Add to existing Socket.io types
interface ServerToClientEvents {
  // ‚úÖ Existing events already handled in gameHandlers.ts

  // üîß Add: Turn-specific events
  'turn:updated': (turnData: TurnUpdateData) => void;
  'turn:timeout': (timeoutData: { playerId: number; newState: GameState }) => void;
  'turn:timer_started': (timerData: { duration: number; deadline: number }) => void;
  'phase:transition': (phaseData: { from: GamePhase; to: GamePhase; auto: boolean }) => void;
}

interface TurnUpdateData {
  currentPlayer: number;
  turn: number;
  phase: GamePhase;
  timeRemaining?: number;
  phaseStartedAt: Date;
}
```

### Integration with Existing Handlers
```typescript
// üîß Enhancement to existing gameHandlers.ts
export const enhanceTurnHandlers = (socket: Socket, io: Server) => {
  // Integrate turn timer with existing turn events
  socket.on('game:action', async (actionData: GameActionData, callback) => {
    try {
      // ‚úÖ Existing action handling logic remains
      const result = await executeGameAction(actionData);

      // üîß Add: Reset turn timer on action
      if (result.success && actionData.actionType !== 'end_turn') {
        turnTimerService.startTurnTimer(
          actionData.gameId,
          result.gameState.currentPlayer,
          300 // 5 minutes
        );
      }

      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });
};
```

## üé® Frontend Integration Requirements

### Required Component Enhancements
```typescript
// üîß Add to existing GameBoard component
interface TurnTimerProps {
  timeRemaining: number;
  isMyTurn: boolean;
  onTimeExpired: () => void;
}

const TurnTimer: React.FC<TurnTimerProps> = ({ timeRemaining, isMyTurn, onTimeExpired }) => {
  useEffect(() => {
    if (timeRemaining <= 0 && isMyTurn) {
      onTimeExpired();
    }
  }, [timeRemaining, isMyTurn]);

  return (
    <div className={`turn-timer ${isMyTurn ? 'active' : 'waiting'}`}>
      <div className="time-display">
        {Math.floor(timeRemaining / 60)}:{(timeRemaining % 60).toString().padStart(2, '0')}
      </div>
      <div className="timer-bar">
        <div
          className="timer-fill"
          style={{ width: `${(timeRemaining / 300) * 100}%` }}
        />
      </div>
    </div>
  );
};

// üîß Enhanced turn management hook with timer support
const useTurnManagement = (gameId: string) => {
  const socket = useSocket();
  const [turnState, setTurnState] = useState<TurnState | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<number>(300); // 5 minutes

  useEffect(() => {
    socket.on('turn:updated', (turnData: TurnUpdateData) => {
      setTurnState({
        currentPlayer: turnData.currentPlayer,
        turn: turnData.turn,
        phase: turnData.phase,
        gameState: turnData as any // Type conversion for compatibility
      });
      setTimeRemaining(turnData.timeRemaining || 300);
    });

    socket.on('turn:timer_started', ({ duration, deadline }) => {
      setTimeRemaining(Math.max(0, Math.floor((deadline - Date.now()) / 1000)));
    });

    const interval = setInterval(() => {
      setTimeRemaining(prev => Math.max(0, prev - 1));
    }, 1000);

    return () => {
      clearInterval(interval);
      socket.off('turn:updated');
      socket.off('turn:timer_started');
    };
  }, [socket]);

  return { turnState, timeRemaining };
};
```

## ‚úÖ Acceptance Criteria

### Turn Flow
- [ ] Smooth progression through all three phases
- [ ] Automatic phase transitions with appropriate delays
- [ ] Manual turn ending during actions phase
- [ ] Turn validation prevents out-of-turn actions
- [ ] Phase validation prevents wrong-phase actions

### Resource Management
- [ ] Void Echoes increase correctly (+1 per turn, max 10)
- [ ] Resource spending validation prevents overspending
- [ ] Real-time resource display updates
- [ ] Resource state synchronization between players

### Card Draw System
- [ ] Automatic card draw during draw phase
- [ ] Hand limit enforcement (max 7 cards)
- [ ] Deck empty detection triggers victory
- [ ] Draw animations and visual feedback

### Victory Conditions
- [ ] Deck empty victory detection works correctly
- [ ] Game end state properly set and synchronized
- [ ] Victory announcement clear and immediate
- [ ] Framework ready for future quest-based victories

## üß™ Testing Strategy

### Unit Tests
- Turn phase transitions
- Resource calculation accuracy
- Victory condition detection
- Turn validation logic

### Integration Tests
- Socket.io turn event handling
- Database state persistence
- Real-time synchronization
- Multi-player turn coordination

### Game Flow Tests
- Complete game scenarios
- Edge cases (empty deck, full hand)
- Victory condition scenarios
- Turn timing and transitions

### Performance Tests
- Turn transition speed
- Database query optimization
- Memory usage during long games
- Concurrent game handling

## üì¶ Deliverables

1. **TurnManager Service**: Complete turn management system
2. **VictoryService**: Victory condition detection and handling
3. **Socket.io Integration**: Real-time turn and phase events
4. **Frontend Components**: Turn display and resource management
5. **Database Schema**: Turn history and phase tracking
6. **Tests**: Comprehensive turn management test suite
7. **Documentation**: Turn system and victory condition guides

## üöÄ Implementation Notes

### Turn Timing
- Phase transitions use appropriate delays for visual feedback
- Optional turn timers can be added for competitive play
- Turn validation prevents race conditions

### Victory Extension
- Framework designed for easy addition of quest-based victories
- Victory conditions are modular and extensible
- Support for complex multi-condition victories

### Performance Optimization
- Efficient turn state queries
- Minimal database updates per turn
- Cached victory condition checks

This turn management system provides the complete game flow structure necessary for engaging tactical gameplay in TCG Tactique.