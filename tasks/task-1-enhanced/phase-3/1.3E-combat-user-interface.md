# Task 1.3E: Combat User Interface

**Phase**: 3 - Game Mechanics
**Priority**: High
**Estimated Time**: 4-5 days
**Dependencies**: Task 1.3D (Combat Logic Engine), Task 1.3C (Drag & Drop Interface)

## üéØ Objective

Create an engaging frontend combat experience with intuitive target selection, clear visual feedback, smooth animations, and comprehensive display of faction passive abilities and combat results.

## üìã Requirements

### Functional Requirements

#### Target Selection System
- **Unit Selection**: Click attacking unit to enter combat mode
- **Range Display**: Highlight valid target positions based on unit range
- **Target Highlighting**: Clear visual indication of attackable enemies
- **Selection Feedback**: Visual confirmation of selected attacker and target
- **Mode Switching**: Easy transition between placement and combat modes

#### Visual Range & Targeting
- **Range Visualization**: Color-coded range indicators (1=red, 2=orange, 3=yellow)
- **Line of Sight**: Visual line from attacker to potential targets
- **Grid Highlighting**: Faction-specific colors for range areas
- **Invalid Targets**: Clear indication of units out of range
- **Range Calculation**: Real-time range validation with visual feedback

#### Combat Animation System
- **Attack Animations**: Visual projectiles or effect lines
- **Damage Numbers**: Floating damage indicators with easing
- **Unit Reactions**: Health bar updates and hit reactions
- **Death Animations**: Unit destruction with particle effects
- **Faction Effects**: Unique visual effects for each faction's abilities

#### Passive Ability Display
- **Visual Indicators**: Icons showing active passive abilities
- **Effect Highlights**: Visual representation of passive bonuses
- **Status Effects**: Buffs/debuffs displayed on units
- **Trigger Animations**: Visual feedback when passives activate
- **Tooltip Information**: Detailed passive ability descriptions

### Technical Requirements

#### Component Architecture
```typescript
// Combat interface component
interface CombatInterfaceProps {
  gameState: GameState;
  selectedUnit?: PlacedCard;
  selectedPosition?: Position;
  onUnitSelect: (position: Position) => void;
  onAttack: (attackerPos: Position, targetPos: Position) => Promise<void>;
  onCancelCombat: () => void;
  isPlayerTurn: boolean;
}

// Combat overlay component
interface CombatOverlayProps {
  attackerPosition: Position;
  targetPosition?: Position;
  validTargets: Position[];
  rangeDisplay: RangeDisplay;
  onTargetSelect: (position: Position) => void;
  onCancel: () => void;
}

// Range display data
interface RangeDisplay {
  positions: Position[];
  range: number;
  attackType: 'melee' | 'ranged' | 'special';
}
```

#### Animation System
```typescript
// Combat animation manager
interface CombatAnimationManager {
  playAttackAnimation(from: Position, to: Position, attackType: string): Promise<void>;
  showDamageNumbers(position: Position, damage: number, type: 'damage' | 'heal'): void;
  playDeathAnimation(position: Position, unit: PlacedCard): Promise<void>;
  showPassiveEffect(effect: PassiveEffect, positions: Position[]): void;
  highlightRange(positions: Position[], range: number): void;
  clearHighlights(): void;
}

// Animation configuration
interface AnimationConfig {
  attackDuration: number;
  damageFloatDuration: number;
  deathFadeDuration: number;
  passiveGlowDuration: number;
  easingFunction: string;
}
```

## üèóÔ∏è Technical Architecture

### Combat Interface Components

#### CombatInterface Component
```typescript
const CombatInterface: React.FC<CombatInterfaceProps> = ({
  gameState,
  selectedUnit,
  selectedPosition,
  onUnitSelect,
  onAttack,
  onCancelCombat,
  isPlayerTurn
}) => {
  const [combatMode, setCombatMode] = useState<'select' | 'target' | 'animating'>('select');
  const [validTargets, setValidTargets] = useState<Position[]>([]);
  const [rangeDisplay, setRangeDisplay] = useState<RangeDisplay | null>(null);

  const animationManager = useCombatAnimations();

  // Handle unit selection for combat
  const handleUnitSelect = (position: Position) => {
    if (!isPlayerTurn) return;

    const unit = getUnitAtPosition(gameState, position);
    if (!unit || !isPlayerUnit(unit, gameState.currentPlayerId)) return;

    // Calculate valid targets
    const targets = calculateValidTargets(unit, position, gameState);
    const range = calculateRangeDisplay(unit, position);

    setValidTargets(targets);
    setRangeDisplay(range);
    setCombatMode('target');
    onUnitSelect(position);

    // Show range visualization
    animationManager.highlightRange(range.positions, unit.range);
  };

  // Handle target selection
  const handleTargetSelect = async (targetPosition: Position) => {
    if (!selectedPosition || combatMode !== 'target') return;

    setCombatMode('animating');

    try {
      // Play attack animation
      await animationManager.playAttackAnimation(
        selectedPosition,
        targetPosition,
        selectedUnit?.type || 'melee'
      );

      // Execute combat on backend
      await onAttack(selectedPosition, targetPosition);

    } catch (error) {
      console.error('Combat failed:', error);
      // Handle error with user feedback
    } finally {
      setCombatMode('select');
      animationManager.clearHighlights();
    }
  };

  const handleCancelCombat = () => {
    setCombatMode('select');
    setValidTargets([]);
    setRangeDisplay(null);
    animationManager.clearHighlights();
    onCancelCombat();
  };

  return (
    <div className="combat-interface">
      {/* Combat Mode Indicator */}
      {combatMode !== 'select' && (
        <div className="combat-mode-indicator">
          <h3>Combat Mode</h3>
          {selectedUnit && (
            <div className="selected-unit-info">
              <span>{selectedUnit.name}</span>
              <span>ATK: {selectedUnit.attack}</span>
              <span>Range: {selectedUnit.range}</span>
            </div>
          )}
          <button onClick={handleCancelCombat} className="cancel-combat">
            Cancel Combat
          </button>
        </div>
      )}

      {/* Combat Overlay */}
      {combatMode === 'target' && rangeDisplay && (
        <CombatOverlay
          attackerPosition={selectedPosition!}
          validTargets={validTargets}
          rangeDisplay={rangeDisplay}
          onTargetSelect={handleTargetSelect}
          onCancel={handleCancelCombat}
        />
      )}

      {/* Game Board with Combat Interactions */}
      <GameBoard
        gameState={gameState}
        onCellClick={combatMode === 'select' ? handleUnitSelect : handleTargetSelect}
        combatMode={combatMode}
        validTargets={validTargets}
        selectedPosition={selectedPosition}
      />
    </div>
  );
};
```

#### Combat Overlay Component
```typescript
const CombatOverlay: React.FC<CombatOverlayProps> = ({
  attackerPosition,
  validTargets,
  rangeDisplay,
  onTargetSelect,
  onCancel
}) => {
  return (
    <div className="combat-overlay">
      {/* Range visualization */}
      <svg className="range-overlay" viewBox="0 0 500 300">
        {rangeDisplay.positions.map((pos, index) => (
          <circle
            key={index}
            cx={pos.x * 100 + 50}
            cy={pos.y * 100 + 50}
            r="40"
            className={`range-circle range-${rangeDisplay.range}`}
            opacity="0.3"
          />
        ))}

        {/* Attack lines to valid targets */}
        {validTargets.map((target, index) => (
          <line
            key={index}
            x1={attackerPosition.x * 100 + 50}
            y1={attackerPosition.y * 100 + 50}
            x2={target.x * 100 + 50}
            y2={target.y * 100 + 50}
            className="attack-line"
            strokeDasharray="5,5"
          />
        ))}
      </svg>

      {/* Combat instructions */}
      <div className="combat-instructions">
        <p>Select a target to attack</p>
        <button onClick={onCancel}>Cancel</button>
      </div>
    </div>
  );
};
```

### Animation System

#### Combat Animations Hook
```typescript
const useCombatAnimations = () => {
  const [animations, setAnimations] = useState<Map<string, Animation>>(new Map());

  const playAttackAnimation = async (
    from: Position,
    to: Position,
    attackType: string
  ): Promise<void> => {
    return new Promise((resolve) => {
      const animationId = `attack-${Date.now()}`;

      // Create projectile or effect
      const element = createProjectileElement(from, to, attackType);
      document.body.appendChild(element);

      // Animate projectile
      const animation = element.animate([
        {
          transform: `translate(${from.x * 100}px, ${from.y * 100}px)`,
          opacity: 1
        },
        {
          transform: `translate(${to.x * 100}px, ${to.y * 100}px)`,
          opacity: 0.8
        }
      ], {
        duration: 300,
        easing: 'ease-out'
      });

      animation.onfinish = () => {
        document.body.removeChild(element);
        resolve();
      };

      setAnimations(prev => prev.set(animationId, animation));
    });
  };

  const showDamageNumbers = (
    position: Position,
    damage: number,
    type: 'damage' | 'heal'
  ): void => {
    const element = createDamageElement(damage, type);
    const gridCell = document.querySelector(`[data-position="${position.x}-${position.y}"]`);

    if (gridCell) {
      gridCell.appendChild(element);

      element.animate([
        {
          transform: 'translateY(0px)',
          opacity: 1
        },
        {
          transform: 'translateY(-40px)',
          opacity: 0
        }
      ], {
        duration: 1000,
        easing: 'ease-out'
      }).onfinish = () => {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      };
    }
  };

  const playDeathAnimation = async (
    position: Position,
    unit: PlacedCard
  ): Promise<void> => {
    return new Promise((resolve) => {
      const element = document.querySelector(
        `[data-position="${position.x}-${position.y}"] .unit-card`
      );

      if (element) {
        const animation = element.animate([
          { opacity: 1, transform: 'scale(1)' },
          { opacity: 0, transform: 'scale(0.8)' }
        ], {
          duration: 500,
          easing: 'ease-in'
        });

        animation.onfinish = () => resolve();
      } else {
        resolve();
      }
    });
  };

  const showPassiveEffect = (
    effect: PassiveEffect,
    positions: Position[]
  ): void => {
    positions.forEach(pos => {
      const element = document.querySelector(
        `[data-position="${pos.x}-${pos.y}"]`
      );

      if (element) {
        element.classList.add(`passive-${effect.type}`);

        setTimeout(() => {
          element.classList.remove(`passive-${effect.type}`);
        }, 2000);
      }
    });
  };

  const highlightRange = (positions: Position[], range: number): void => {
    positions.forEach(pos => {
      const element = document.querySelector(
        `[data-position="${pos.x}-${pos.y}"]`
      );

      if (element) {
        element.classList.add('in-range', `range-${range}`);
      }
    });
  };

  const clearHighlights = (): void => {
    document.querySelectorAll('.grid-cell').forEach(cell => {
      cell.classList.remove('in-range', 'range-1', 'range-2', 'range-3');
    });
  };

  return {
    playAttackAnimation,
    showDamageNumbers,
    playDeathAnimation,
    showPassiveEffect,
    highlightRange,
    clearHighlights
  };
};
```

### Combat Result Handling

#### Combat Events Hook
```typescript
const useCombatEvents = () => {
  const socket = useSocket();
  const animationManager = useCombatAnimations();

  useEffect(() => {
    // Handle combat results
    socket.on('game:combat_result', (result: CombatResult) => {
      handleCombatResult(result);
    });

    // Handle unit destruction
    socket.on('game:unit_destroyed', (position: Position, unit: PlacedCard) => {
      animationManager.playDeathAnimation(position, unit);
    });

    // Handle passive effects
    socket.on('game:passive_triggered', (effect: PassiveEffect) => {
      animationManager.showPassiveEffect(effect, effect.affected || []);
    });

    // Handle damage display
    socket.on('game:damage_dealt', (position: Position, damage: number) => {
      animationManager.showDamageNumbers(position, damage, 'damage');
    });

    return () => {
      socket.off('game:combat_result');
      socket.off('game:unit_destroyed');
      socket.off('game:passive_triggered');
      socket.off('game:damage_dealt');
    };
  }, [socket, animationManager]);

  const handleCombatResult = async (result: CombatResult) => {
    // Show damage numbers
    if (result.attackerDamage > 0) {
      animationManager.showDamageNumbers(
        result.targetPosition,
        result.attackerDamage,
        'damage'
      );
    }

    if (result.defenderDamage > 0) {
      animationManager.showDamageNumbers(
        result.attackerPosition,
        result.defenderDamage,
        'damage'
      );
    }

    // Play death animations if needed
    if (result.attackerDestroyed) {
      await animationManager.playDeathAnimation(
        result.attackerPosition,
        result.combatLog[0].attacker
      );
    }

    if (result.defenderDestroyed) {
      await animationManager.playDeathAnimation(
        result.targetPosition,
        result.combatLog[0].defender
      );
    }

    // Show passive effects
    result.passiveEffects.forEach(effect => {
      animationManager.showPassiveEffect(effect, effect.affected || []);
    });
  };

  return {
    handleCombatResult
  };
};
```

## üé® Visual Design

### CSS Combat Styling
```css
/* Combat Interface */
.combat-interface {
  position: relative;
  width: 100%;
  height: 100%;
}

.combat-mode-indicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1rem;
  border-radius: 8px;
  z-index: 100;
}

.selected-unit-info {
  display: flex;
  gap: 0.5rem;
  margin: 0.5rem 0;
}

.cancel-combat {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
}

/* Range Visualization */
.range-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.range-circle {
  fill: currentColor;
  stroke: currentColor;
  stroke-width: 2;
}

.range-1 { color: #ef4444; } /* Red for melee */
.range-2 { color: #f97316; } /* Orange for ranged */
.range-3 { color: #eab308; } /* Yellow for long range */

.attack-line {
  stroke: #10b981;
  stroke-width: 2;
  opacity: 0.7;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  0% { stroke-dashoffset: 0; }
  100% { stroke-dashoffset: 10; }
}

/* Grid Cell Combat States */
.grid-cell.in-range {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.2);
  cursor: crosshair;
}

.grid-cell.valid-target {
  border-color: #ef4444;
  background: rgba(239, 68, 68, 0.3);
  animation: targetPulse 1s ease-in-out infinite;
}

@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
  50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
}

.grid-cell.selected-attacker {
  border-color: #3b82f6;
  background: rgba(59, 130, 246, 0.4);
  box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
}

/* Passive Effects */
.passive-line_bonus {
  box-shadow: 0 0 20px #fbbf24;
  animation: lineBonus 2s ease-in-out;
}

.passive-evolution_adaptation {
  box-shadow: 0 0 20px #10b981;
  animation: evolutionPulse 1.5s ease-in-out;
}

.passive-reanimation {
  animation: resurrect 2s ease-in-out;
}

@keyframes lineBonus {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.3) hue-rotate(45deg); }
}

@keyframes evolutionPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

@keyframes resurrect {
  0% { opacity: 0; transform: scale(0.5); }
  50% { opacity: 1; transform: scale(1.2); }
  100% { opacity: 1; transform: scale(1); }
}

/* Damage Numbers */
.damage-number {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  font-weight: bold;
  color: #ef4444;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  z-index: 200;
}

.damage-number.heal {
  color: #10b981;
}

/* Projectile Effects */
.projectile {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #fbbf24;
  border-radius: 50%;
  box-shadow: 0 0 10px #fbbf24;
  pointer-events: none;
  z-index: 150;
}

.projectile.melee {
  width: 20px;
  height: 4px;
  background: #ef4444;
  border-radius: 2px;
}

/* Combat Instructions */
.combat-instructions {
  position: absolute;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1rem;
  border-radius: 8px;
  text-align: center;
}
```

## üîå Integration Requirements

### Backend Integration
- Connect to Combat Engine (Task 1.3D) via Socket.io
- Handle combat validation responses
- Process combat results and animations
- Sync with real-time game state updates

### Animation Performance
- 60fps animations for all combat effects
- Efficient DOM manipulation
- Hardware-accelerated CSS transforms
- Minimal memory usage during animations

### State Management
- Integrate with game state hooks
- Maintain UI state during combat
- Handle animation cleanup
- Manage concurrent combat scenarios

## ‚úÖ Acceptance Criteria

### Combat Interaction
- [ ] Intuitive unit selection and targeting
- [ ] Clear visual feedback for all combat states
- [ ] Smooth transitions between combat modes
- [ ] Error handling for invalid combat actions
- [ ] Mobile-friendly touch interactions

### Visual Feedback
- [ ] Range visualization for all unit types
- [ ] Damage numbers with smooth animations
- [ ] Faction-specific passive effect indicators
- [ ] Death animations with visual impact
- [ ] Attack animations for different weapon types

### Performance
- [ ] All animations maintain 60fps
- [ ] Combat interface responsive <100ms
- [ ] Memory usage stable during extended combat
- [ ] No visual glitches or animation conflicts

### User Experience
- [ ] Clear combat mode indicators
- [ ] Easy combat cancellation
- [ ] Accessible design with screen reader support
- [ ] Consistent visual language across all combat elements

## üß™ Testing Strategy

### Component Tests
- Combat interface state management
- Animation timing and completion
- Target selection validation
- Visual feedback accuracy

### Integration Tests
- Socket.io combat event handling
- Backend combat result processing
- Animation synchronization
- State consistency during combat

### Visual Tests
- Animation quality and smoothness
- Cross-browser rendering consistency
- Mobile responsiveness
- Accessibility compliance

### Performance Tests
- Animation frame rate monitoring
- Memory usage during combat
- GPU usage optimization
- Concurrent animation handling

## üì¶ Deliverables

1. **CombatInterface Component**: Complete combat interaction system
2. **Animation System**: Smooth combat animations and effects
3. **Visual Feedback**: Range, targeting, and passive effect displays
4. **Socket Integration**: Real-time combat event handling
5. **Responsive Design**: Mobile and desktop optimized styling
6. **Accessibility Features**: Screen reader and keyboard support
7. **Tests**: Comprehensive combat UI test suite
8. **Documentation**: Combat interface usage and customization guide

## üöÄ Implementation Notes

### Animation Optimization
- Use CSS transforms for hardware acceleration
- Implement animation pooling for repeated effects
- Optimize DOM queries with caching
- Use RAF for smooth animation timing

### Accessibility
- ARIA labels for combat states
- Keyboard shortcuts for combat actions
- High contrast mode support
- Screen reader announcements for combat results

### Mobile Optimization
- Touch-friendly target sizes
- Gesture recognition for combat actions
- Haptic feedback for combat events
- Optimized animations for mobile performance

This combat interface creates an engaging and intuitive combat experience that brings the tactical depth of TCG Tactique to life with clear visual feedback and smooth animations.