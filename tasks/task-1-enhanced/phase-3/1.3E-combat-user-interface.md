# Task 1.3E: Combat User Interface

**Phase**: 3 - Game Mechanics
**Priority**: High
**Estimated Time**: 2-3 days
**Dependencies**: ‚ö†Ô∏è **BLOCKED** - Requires Task 1.3D (Combat Logic Engine) to be completed first

## üéØ Objective

Create the frontend combat UI layer that integrates with the existing excellent drag-drop system (1.3C) and connects to the backend Combat Logic Engine (1.3D). Focus on intuitive target selection, visual feedback, and smooth animations for tactical combat interactions.

## ‚ö†Ô∏è Important Context

**Current Reality Check**:
- ‚úÖ **Drag-Drop Interface (1.3C)**: 95% complete with excellent implementation
- ‚ùå **Combat Logic Engine (1.3D)**: 0% implemented - THIS IS THE BLOCKER
- üìä **Overall Phase 3**: 92% complete but missing the critical combat backend

**This task focuses on**:
- Frontend UI integration with existing drag-drop system
- Visual feedback and animation layers
- Socket.io event handling for combat events
- UI state management during combat phases

**This task does NOT include**:
- Backend combat logic (that's 1.3D)
- Attack validation (that's 1.3D)
- Faction passive abilities (that's 1.3D)
- Damage calculation (that's 1.3D)

## üìã Requirements

### Frontend UI Requirements

#### Combat Mode Integration
- **Mode Toggle**: Extend existing drag-drop system with combat mode
- **UI State Management**: Switch between placement and combat phases
- **Visual Mode Indicators**: Clear indication of current interaction mode
- **Integration with 1.3C**: Build upon the excellent existing drag-drop foundation

#### Target Selection Interface
- **Unit Selection**: Click/tap attacking unit to enter target selection
- **Visual Feedback**: Highlight selected attacker with distinct styling
- **Target Highlighting**: Show potential targets (data from 1.3D backend)
- **Selection Confirmation**: Clear visual confirmation of attacker ‚Üí target
- **Cancel Combat**: Easy way to exit combat mode and return to placement

#### Visual Display System
- **Range Visualization**: Display attack ranges provided by backend (1.3D)
- **Color-Coded Ranges**: Different colors for range 1, 2, 3 (red, orange, yellow)
- **Attack Preview**: Visual line from attacker to hovered target
- **Invalid Target Feedback**: Gray out or dim unreachable enemies
- **Grid Integration**: Leverage existing grid system from 1.3C

#### Animation & Feedback Layer
- **Attack Animations**: Smooth visual projectiles or effect lines
- **Damage Display**: Floating damage numbers from combat results
- **Health Bar Updates**: Visual health changes on units
- **Unit Destruction**: Death animations and removal effects
- **Passive Indicators**: Visual cues when faction abilities trigger (data from 1.3D)

#### Socket.io Event Handling
- **Combat Events**: Listen for combat results from 1.3D backend
- **Animation Triggers**: React to server combat resolution
- **State Synchronization**: Update UI based on game state changes
- **Error Handling**: Display user-friendly combat error messages

### Frontend Integration Requirements

#### Component Integration Strategy
```typescript
// Extend existing GameBoard component from 1.3C
interface GameBoardProps {
  // Existing props from 1.3C drag-drop
  gameState: GameState;
  onCardPlace: (card: Card, position: Position) => void;

  // NEW: Combat mode props
  combatMode: 'placement' | 'combat_select' | 'combat_target';
  selectedAttacker?: Position;
  validTargets: Position[];
  onCombatSelect: (position: Position) => void;
  onCombatAttack: (attackerPos: Position, targetPos: Position) => Promise<void>;
}

// NEW: Combat UI overlay component
interface CombatOverlayProps {
  attackerPosition: Position;
  availableTargets: Position[]; // From 1.3D backend API
  rangeData: RangeVisualization; // From 1.3D backend API
  onTargetSelect: (position: Position) => void;
  onCancel: () => void;
}

// Data interfaces for backend integration
interface RangeVisualization {
  positions: Position[];
  range: number;
  lineOfSight: boolean;
}

interface CombatEventData {
  type: 'attack_result' | 'unit_destroyed' | 'passive_triggered';
  payload: any; // From 1.3D combat events
}
```

#### Animation System
```typescript
// Combat animation manager
interface CombatAnimationManager {
  playAttackAnimation(from: Position, to: Position, attackType: string): Promise<void>;
  showDamageNumbers(position: Position, damage: number, type: 'damage' | 'heal'): void;
  playDeathAnimation(position: Position, unit: PlacedCard): Promise<void>;
  showPassiveEffect(effect: PassiveEffect, positions: Position[]): void;
  highlightRange(positions: Position[], range: number): void;
  clearHighlights(): void;
}

// Animation configuration
interface AnimationConfig {
  attackDuration: number;
  damageFloatDuration: number;
  deathFadeDuration: number;
  passiveGlowDuration: number;
  easingFunction: string;
}
```

## üèóÔ∏è Technical Architecture

### Combat Interface Components

#### CombatInterface Component
```typescript
const CombatInterface: React.FC<CombatInterfaceProps> = ({
  gameState,
  selectedUnit,
  selectedPosition,
  onUnitSelect,
  onAttack,
  onCancelCombat,
  isPlayerTurn
}) => {
  const [combatMode, setCombatMode] = useState<'select' | 'target' | 'animating'>('select');
  const [validTargets, setValidTargets] = useState<Position[]>([]);
  const [rangeDisplay, setRangeDisplay] = useState<RangeDisplay | null>(null);

  const animationManager = useCombatAnimations();

  // Handle unit selection for combat
  const handleUnitSelect = (position: Position) => {
    if (!isPlayerTurn) return;

    const unit = getUnitAtPosition(gameState, position);
    if (!unit || !isPlayerUnit(unit, gameState.currentPlayerId)) return;

    // Calculate valid targets
    const targets = calculateValidTargets(unit, position, gameState);
    const range = calculateRangeDisplay(unit, position);

    setValidTargets(targets);
    setRangeDisplay(range);
    setCombatMode('target');
    onUnitSelect(position);

    // Show range visualization
    animationManager.highlightRange(range.positions, unit.range);
  };

  // Handle target selection
  const handleTargetSelect = async (targetPosition: Position) => {
    if (!selectedPosition || combatMode !== 'target') return;

    setCombatMode('animating');

    try {
      // Play attack animation
      await animationManager.playAttackAnimation(
        selectedPosition,
        targetPosition,
        selectedUnit?.type || 'melee'
      );

      // Execute combat on backend
      await onAttack(selectedPosition, targetPosition);

    } catch (error) {
      console.error('Combat failed:', error);
      // Handle error with user feedback
    } finally {
      setCombatMode('select');
      animationManager.clearHighlights();
    }
  };

  const handleCancelCombat = () => {
    setCombatMode('select');
    setValidTargets([]);
    setRangeDisplay(null);
    animationManager.clearHighlights();
    onCancelCombat();
  };

  return (
    <div className="combat-interface">
      {/* Combat Mode Indicator */}
      {combatMode !== 'select' && (
        <div className="combat-mode-indicator">
          <h3>Combat Mode</h3>
          {selectedUnit && (
            <div className="selected-unit-info">
              <span>{selectedUnit.name}</span>
              <span>ATK: {selectedUnit.attack}</span>
              <span>Range: {selectedUnit.range}</span>
            </div>
          )}
          <button onClick={handleCancelCombat} className="cancel-combat">
            Cancel Combat
          </button>
        </div>
      )}

      {/* Combat Overlay */}
      {combatMode === 'target' && rangeDisplay && (
        <CombatOverlay
          attackerPosition={selectedPosition!}
          validTargets={validTargets}
          rangeDisplay={rangeDisplay}
          onTargetSelect={handleTargetSelect}
          onCancel={handleCancelCombat}
        />
      )}

      {/* Game Board with Combat Interactions */}
      <GameBoard
        gameState={gameState}
        onCellClick={combatMode === 'select' ? handleUnitSelect : handleTargetSelect}
        combatMode={combatMode}
        validTargets={validTargets}
        selectedPosition={selectedPosition}
      />
    </div>
  );
};
```

#### Combat Overlay Component
```typescript
const CombatOverlay: React.FC<CombatOverlayProps> = ({
  attackerPosition,
  validTargets,
  rangeDisplay,
  onTargetSelect,
  onCancel
}) => {
  return (
    <div className="combat-overlay">
      {/* Range visualization */}
      <svg className="range-overlay" viewBox="0 0 500 300">
        {rangeDisplay.positions.map((pos, index) => (
          <circle
            key={index}
            cx={pos.x * 100 + 50}
            cy={pos.y * 100 + 50}
            r="40"
            className={`range-circle range-${rangeDisplay.range}`}
            opacity="0.3"
          />
        ))}

        {/* Attack lines to valid targets */}
        {validTargets.map((target, index) => (
          <line
            key={index}
            x1={attackerPosition.x * 100 + 50}
            y1={attackerPosition.y * 100 + 50}
            x2={target.x * 100 + 50}
            y2={target.y * 100 + 50}
            className="attack-line"
            strokeDasharray="5,5"
          />
        ))}
      </svg>

      {/* Combat instructions */}
      <div className="combat-instructions">
        <p>Select a target to attack</p>
        <button onClick={onCancel}>Cancel</button>
      </div>
    </div>
  );
};
```

### Animation System

#### Combat Animations Hook
```typescript
const useCombatAnimations = () => {
  const [animations, setAnimations] = useState<Map<string, Animation>>(new Map());

  const playAttackAnimation = async (
    from: Position,
    to: Position,
    attackType: string
  ): Promise<void> => {
    return new Promise((resolve) => {
      const animationId = `attack-${Date.now()}`;

      // Create projectile or effect
      const element = createProjectileElement(from, to, attackType);
      document.body.appendChild(element);

      // Animate projectile
      const animation = element.animate([
        {
          transform: `translate(${from.x * 100}px, ${from.y * 100}px)`,
          opacity: 1
        },
        {
          transform: `translate(${to.x * 100}px, ${to.y * 100}px)`,
          opacity: 0.8
        }
      ], {
        duration: 300,
        easing: 'ease-out'
      });

      animation.onfinish = () => {
        document.body.removeChild(element);
        resolve();
      };

      setAnimations(prev => prev.set(animationId, animation));
    });
  };

  const showDamageNumbers = (
    position: Position,
    damage: number,
    type: 'damage' | 'heal'
  ): void => {
    const element = createDamageElement(damage, type);
    const gridCell = document.querySelector(`[data-position="${position.x}-${position.y}"]`);

    if (gridCell) {
      gridCell.appendChild(element);

      element.animate([
        {
          transform: 'translateY(0px)',
          opacity: 1
        },
        {
          transform: 'translateY(-40px)',
          opacity: 0
        }
      ], {
        duration: 1000,
        easing: 'ease-out'
      }).onfinish = () => {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      };
    }
  };

  const playDeathAnimation = async (
    position: Position,
    unit: PlacedCard
  ): Promise<void> => {
    return new Promise((resolve) => {
      const element = document.querySelector(
        `[data-position="${position.x}-${position.y}"] .unit-card`
      );

      if (element) {
        const animation = element.animate([
          { opacity: 1, transform: 'scale(1)' },
          { opacity: 0, transform: 'scale(0.8)' }
        ], {
          duration: 500,
          easing: 'ease-in'
        });

        animation.onfinish = () => resolve();
      } else {
        resolve();
      }
    });
  };

  const showPassiveEffect = (
    effect: PassiveEffect,
    positions: Position[]
  ): void => {
    positions.forEach(pos => {
      const element = document.querySelector(
        `[data-position="${pos.x}-${pos.y}"]`
      );

      if (element) {
        element.classList.add(`passive-${effect.type}`);

        setTimeout(() => {
          element.classList.remove(`passive-${effect.type}`);
        }, 2000);
      }
    });
  };

  const highlightRange = (positions: Position[], range: number): void => {
    positions.forEach(pos => {
      const element = document.querySelector(
        `[data-position="${pos.x}-${pos.y}"]`
      );

      if (element) {
        element.classList.add('in-range', `range-${range}`);
      }
    });
  };

  const clearHighlights = (): void => {
    document.querySelectorAll('.grid-cell').forEach(cell => {
      cell.classList.remove('in-range', 'range-1', 'range-2', 'range-3');
    });
  };

  return {
    playAttackAnimation,
    showDamageNumbers,
    playDeathAnimation,
    showPassiveEffect,
    highlightRange,
    clearHighlights
  };
};
```

### Combat Result Handling

#### Combat Events Hook
```typescript
const useCombatEvents = () => {
  const socket = useSocket();
  const animationManager = useCombatAnimations();

  useEffect(() => {
    // Handle combat results
    socket.on('game:combat_result', (result: CombatResult) => {
      handleCombatResult(result);
    });

    // Handle unit destruction
    socket.on('game:unit_destroyed', (position: Position, unit: PlacedCard) => {
      animationManager.playDeathAnimation(position, unit);
    });

    // Handle passive effects
    socket.on('game:passive_triggered', (effect: PassiveEffect) => {
      animationManager.showPassiveEffect(effect, effect.affected || []);
    });

    // Handle damage display
    socket.on('game:damage_dealt', (position: Position, damage: number) => {
      animationManager.showDamageNumbers(position, damage, 'damage');
    });

    return () => {
      socket.off('game:combat_result');
      socket.off('game:unit_destroyed');
      socket.off('game:passive_triggered');
      socket.off('game:damage_dealt');
    };
  }, [socket, animationManager]);

  const handleCombatResult = async (result: CombatResult) => {
    // Show damage numbers
    if (result.attackerDamage > 0) {
      animationManager.showDamageNumbers(
        result.targetPosition,
        result.attackerDamage,
        'damage'
      );
    }

    if (result.defenderDamage > 0) {
      animationManager.showDamageNumbers(
        result.attackerPosition,
        result.defenderDamage,
        'damage'
      );
    }

    // Play death animations if needed
    if (result.attackerDestroyed) {
      await animationManager.playDeathAnimation(
        result.attackerPosition,
        result.combatLog[0].attacker
      );
    }

    if (result.defenderDestroyed) {
      await animationManager.playDeathAnimation(
        result.targetPosition,
        result.combatLog[0].defender
      );
    }

    // Show passive effects
    result.passiveEffects.forEach(effect => {
      animationManager.showPassiveEffect(effect, effect.affected || []);
    });
  };

  return {
    handleCombatResult
  };
};
```

## üé® Visual Design

### CSS Combat Styling
```css
/* Combat Interface */
.combat-interface {
  position: relative;
  width: 100%;
  height: 100%;
}

.combat-mode-indicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1rem;
  border-radius: 8px;
  z-index: 100;
}

.selected-unit-info {
  display: flex;
  gap: 0.5rem;
  margin: 0.5rem 0;
}

.cancel-combat {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
}

/* Range Visualization */
.range-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.range-circle {
  fill: currentColor;
  stroke: currentColor;
  stroke-width: 2;
}

.range-1 { color: #ef4444; } /* Red for melee */
.range-2 { color: #f97316; } /* Orange for ranged */
.range-3 { color: #eab308; } /* Yellow for long range */

.attack-line {
  stroke: #10b981;
  stroke-width: 2;
  opacity: 0.7;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  0% { stroke-dashoffset: 0; }
  100% { stroke-dashoffset: 10; }
}

/* Grid Cell Combat States */
.grid-cell.in-range {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.2);
  cursor: crosshair;
}

.grid-cell.valid-target {
  border-color: #ef4444;
  background: rgba(239, 68, 68, 0.3);
  animation: targetPulse 1s ease-in-out infinite;
}

@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
  50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
}

.grid-cell.selected-attacker {
  border-color: #3b82f6;
  background: rgba(59, 130, 246, 0.4);
  box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
}

/* Passive Effects */
.passive-line_bonus {
  box-shadow: 0 0 20px #fbbf24;
  animation: lineBonus 2s ease-in-out;
}

.passive-evolution_adaptation {
  box-shadow: 0 0 20px #10b981;
  animation: evolutionPulse 1.5s ease-in-out;
}

.passive-reanimation {
  animation: resurrect 2s ease-in-out;
}

@keyframes lineBonus {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.3) hue-rotate(45deg); }
}

@keyframes evolutionPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

@keyframes resurrect {
  0% { opacity: 0; transform: scale(0.5); }
  50% { opacity: 1; transform: scale(1.2); }
  100% { opacity: 1; transform: scale(1); }
}

/* Damage Numbers */
.damage-number {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  font-weight: bold;
  color: #ef4444;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  z-index: 200;
}

.damage-number.heal {
  color: #10b981;
}

/* Projectile Effects */
.projectile {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #fbbf24;
  border-radius: 50%;
  box-shadow: 0 0 10px #fbbf24;
  pointer-events: none;
  z-index: 150;
}

.projectile.melee {
  width: 20px;
  height: 4px;
  background: #ef4444;
  border-radius: 2px;
}

/* Combat Instructions */
.combat-instructions {
  position: absolute;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1rem;
  border-radius: 8px;
  text-align: center;
}
```

## üîå Integration Requirements

### 1.3D Backend Dependency (CRITICAL)
- **API Endpoints**: Combat Logic Engine must provide:
  - `GET /api/game/:id/attack-positions/:position` - Get valid targets
  - `POST /api/game/:id/attack` - Execute attack action
- **Socket Events**: Combat Logic Engine must emit:
  - `game:combat_result` - Attack resolution data
  - `game:unit_destroyed` - Unit death events
  - `game:passive_triggered` - Faction ability activations
- **Data Contracts**: Backend must return structured combat data

### 1.3C Drag-Drop Integration (BUILD UPON)
- **Extend existing components**: Don't rebuild, enhance current implementation
- **Mode switching**: Add combat mode to existing placement system
- **Grid system reuse**: Leverage existing grid cell highlighting
- **Event handling**: Extend current click/touch handlers

### Frontend-Only Requirements
- **Animation Performance**: 60fps animations with CSS transforms
- **UI State Management**: React state for combat mode switching
- **Visual Feedback**: CSS classes for range/target highlighting
- **Socket Client**: Listen for combat events, don't implement logic

## ‚úÖ Acceptance Criteria

### Frontend Integration (Primary Focus)
- [ ] Successfully extends existing 1.3C drag-drop system with combat mode
- [ ] Smooth mode switching between placement and combat phases
- [ ] Visual feedback integrates with existing grid system
- [ ] No regressions to existing placement functionality
- [ ] Mobile-friendly touch interactions maintained

### Combat UI Interface (When 1.3D is ready)
- [ ] Intuitive unit selection for combat initiation
- [ ] Clear target highlighting based on backend range data
- [ ] Visual range display using backend attack position API
- [ ] Smooth attack animations triggered by backend combat results
- [ ] Error handling for backend combat validation failures

### Socket.io Integration
- [ ] Listens correctly for combat events from 1.3D backend
- [ ] Updates UI state based on combat result events
- [ ] Handles unit destruction and passive effect animations
- [ ] Maintains game state synchronization during combat

### Performance & Polish
- [ ] All animations maintain 60fps using CSS transforms
- [ ] Combat interface responsive <100ms for UI state changes
- [ ] Memory usage stable during animation sequences
- [ ] Accessible design with proper ARIA labels and keyboard support

## üß™ Testing Strategy

### Component Tests
- Combat interface state management
- Animation timing and completion
- Target selection validation
- Visual feedback accuracy

### Integration Tests
- Socket.io combat event handling
- Backend combat result processing
- Animation synchronization
- State consistency during combat

### Visual Tests
- Animation quality and smoothness
- Cross-browser rendering consistency
- Mobile responsiveness
- Accessibility compliance

### Performance Tests
- Animation frame rate monitoring
- Memory usage during combat
- GPU usage optimization
- Concurrent animation handling

## üì¶ Deliverables

### Phase 1: Core Integration (Ready to start)
1. **Combat Mode Extension**: Enhance existing GameBoard with combat mode switching
2. **Visual State System**: CSS classes and React state for combat highlighting
3. **Socket Event Handlers**: Listen for combat events (even if 1.3D not ready)
4. **Animation Framework**: CSS animation foundation for combat effects

### Phase 2: Backend Integration (Requires 1.3D)
5. **Target Selection UI**: Connect to backend attack position API
6. **Combat Animations**: Trigger animations from backend combat results
7. **Error Handling**: Display backend validation errors to users
8. **Full Combat Flow**: Complete attacker ‚Üí target ‚Üí result ‚Üí animation cycle

### Supporting Deliverables
- **Tests**: Frontend component tests for combat UI
- **Integration Guide**: How to connect with 1.3D backend when ready
- **Responsive Polish**: Mobile and desktop combat interaction optimization

## üöÄ Implementation Strategy

### Immediate Actions (Day 1-2)
1. **Analyze 1.3C Implementation**: Study existing drag-drop code thoroughly
2. **Design Combat Mode Extension**: Plan how to add combat mode without breaking placement
3. **Create Animation Foundation**: Build CSS animation system for future combat events
4. **Socket Event Scaffolding**: Set up event listeners for future 1.3D integration

### Backend Integration Phase (When 1.3D Ready)
5. **API Integration**: Connect to combat range and attack endpoints
6. **Event Processing**: Handle real combat results and trigger animations
7. **Error Handling**: Display backend validation failures gracefully
8. **Performance Testing**: Ensure smooth real-time combat experience

### Key Success Factors
- **Build on 1.3C Excellence**: Don't reinvent, enhance existing drag-drop system
- **Frontend-First Approach**: Focus on UI layer, let 1.3D handle game logic
- **Graceful Degradation**: UI should work even if backend isn't ready
- **Mobile Optimization**: Maintain excellent touch interaction from 1.3C

### Risk Mitigation
- **1.3D Dependency**: Build UI framework that can connect to backend later
- **No Feature Creep**: Stick to frontend UI, don't implement combat logic
- **Performance First**: Use CSS transforms and efficient React patterns
- **Accessibility**: Ensure combat UI meets WCAG standards

**Estimated Timeline**: 2-3 days for frontend combat UI layer, ready to integrate with 1.3D when available.

This refined scope focuses on what's actually needed: a polished frontend combat interface that integrates with existing excellent systems and prepares for backend integration.