# 1.3D: Combat Logic Engine

## üéØ Task Overview
**Agent**: @backend-architect
**Duration**: 4-5 days
**Dependencies**: 1.3A (Card System), 1.3B (Unit Placement)
**Risk Level**: High
**Priority**: Critical

## üìã Objective
Implement the core combat system with attack range validation, faction passive abilities, damage calculation, and real-time combat result broadcasting. This is the primary missing component for a functional game.

## ‚ùå Current Implementation Status (0% Complete)

### Analysis Discovery
- ‚úÖ **PlacementService exists** with formation validation
- ‚úÖ **Socket.io infrastructure ready** for combat event broadcasting
- ‚úÖ **Card system complete** with attack/health values and abilities
- ‚ùå **No combat logic implemented** - only placement validation exists
- ‚ùå **No attack range validation**
- ‚ùå **No faction passive abilities**
- ‚ùå **No damage calculation system**

## üéØ Deliverables

### 1. Combat Service Architecture
```typescript
// src/services/combatService.ts
interface CombatService {
  // Attack validation and execution
  validateAttack(gameId: string, attackerId: string, attackerPos: Position, targetPos: Position): ValidationResult;
  executeAttack(gameId: string, attackerId: string, attackerPos: Position, targetPos: Position): Promise<CombatResult>;

  // Range and line of sight
  calculateAttackRange(card: Card, position: Position): Position[];
  validateLineOfSight(attackerPos: Position, targetPos: Position, board: GameBoard): boolean;

  // Damage and effects
  calculateDamage(attacker: PlacedCard, target: PlacedCard, gameState: GameState): DamageResult;
  applyDamage(target: PlacedCard, damage: number, effects: StatusEffect[]): PlacedCard;

  // Faction abilities
  applyPassiveAbilities(gameState: GameState, playerId: string): GameState;
  triggerFactionPowers(gameState: GameState, trigger: TriggerEvent): GameState;
}
```

### 2. Combat Data Models
```typescript
// src/types/combat.ts
interface CombatResult {
  success: boolean;
  attackerDamaged: boolean;
  targetDestroyed: boolean;
  damageDealt: number;
  passiveTriggered?: FactionPassive;
  statusEffects?: StatusEffect[];
  gameStateAfter: GameState;
}

interface DamageResult {
  finalDamage: number;
  blocked: number;
  statusEffects: StatusEffect[];
  triggerEffects: TriggerEffect[];
}

interface ValidationResult {
  valid: boolean;
  error?: string;
  errorCode?: 'OUT_OF_RANGE' | 'NO_LINE_OF_SIGHT' | 'INVALID_TARGET' | 'ALREADY_ATTACKED';
}
```

### 3. Faction Passive Abilities System
```typescript
// src/services/factionAbilities.ts
class FactionAbilityManager {
  // Humans: "Ultimate Rampart" - Complete lines get +2 ATK/+1 HP
  applyUltimateRampart(gameState: GameState, playerId: string): GameState {
    const playerBoard = gameState.players[playerId].board;
    const completedLines = this.findCompletedLines(playerBoard);

    completedLines.forEach(line => {
      line.forEach(card => {
        if (card) {
          card.attack += 2;
          card.currentHealth += 1;
          card.maxHealth += 1;
        }
      });
    });

    return gameState;
  }

  // Aliens: "Evolutionary Adaptation" - Dead aliens reduce next summon cost by 1
  applyEvolutionaryAdaptation(gameState: GameState, playerId: string, deadCard: Card): GameState {
    const playerData = gameState.players[playerId];
    playerData.costReduction = Math.min(playerData.costReduction + 1, 10);

    // Add graveyard tracking
    playerData.graveyard.push(deadCard);

    return gameState;
  }

  // Robots: "Reanimation Protocols" - 30% chance to resurrect with 1 HP
  applyReanimationProtocols(gameState: GameState, playerId: string, deadCard: PlacedCard): GameState {
    const resurrectionChance = 0.3;

    if (Math.random() < resurrectionChance) {
      const revivedCard = {
        ...deadCard,
        currentHealth: 1,
        statusEffects: [...deadCard.statusEffects, { type: 'RESURRECTED', duration: 1 }]
      };

      // Place back on board at same position
      gameState.players[playerId].board[deadCard.position.y][deadCard.position.x] = revivedCard;
    }

    return gameState;
  }
}
```

### 4. Attack Range Validation
```typescript
// src/services/rangeCalculator.ts
class RangeCalculator {
  calculateManhattanDistance(pos1: Position, pos2: Position): number {
    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
  }

  getAttackablePositions(card: Card, position: Position, board: GameBoard): Position[] {
    const positions: Position[] = [];
    const range = card.range || 1;

    // For range 1: Adjacent positions only
    if (range === 1) {
      const adjacent = [
        { x: position.x - 1, y: position.y },
        { x: position.x + 1, y: position.y },
        { x: position.x, y: position.y - 1 },
        { x: position.x, y: position.y + 1 }
      ];

      return adjacent.filter(pos =>
        this.isValidPosition(pos) &&
        this.hasEnemyUnit(pos, board)
      );
    }

    // For range 2+: Line of sight validation
    for (let y = 0; y < 3; y++) {
      for (let x = 0; x < 5; x++) {
        const targetPos = { x, y };
        const distance = this.calculateManhattanDistance(position, targetPos);

        if (distance <= range &&
            this.hasLineOfSight(position, targetPos, board) &&
            this.hasEnemyUnit(targetPos, board)) {
          positions.push(targetPos);
        }
      }
    }

    return positions;
  }

  hasLineOfSight(start: Position, end: Position, board: GameBoard): boolean {
    // Simple line of sight: no units blocking the path
    const path = this.getLinePath(start, end);

    // Remove start and end positions from path check
    const blockers = path.slice(1, -1);

    return !blockers.some(pos => board[pos.y][pos.x] !== null);
  }

  private getLinePath(start: Position, end: Position): Position[] {
    // Bresenham's line algorithm for tactical line of sight
    const path: Position[] = [];
    const dx = Math.abs(end.x - start.x);
    const dy = Math.abs(end.y - start.y);
    const sx = start.x < end.x ? 1 : -1;
    const sy = start.y < end.y ? 1 : -1;
    let err = dx - dy;

    let currentPos = { ...start };

    while (true) {
      path.push({ ...currentPos });

      if (currentPos.x === end.x && currentPos.y === end.y) break;

      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        currentPos.x += sx;
      }
      if (e2 < dx) {
        err += dx;
        currentPos.y += sy;
      }
    }

    return path;
  }
}
```

### 5. Socket.io Combat Events
```typescript
// src/socket/handlers/combatHandlers.ts
export function combatEventHandlers(io: Server, socket: Socket) {
  // Attack request
  socket.on('game:attack', async (data: AttackRequest, callback) => {
    try {
      const { gameId, attackerPos, targetPos } = data;

      // Validate attack
      const validation = await combatService.validateAttack(
        gameId,
        socket.data.userId,
        attackerPos,
        targetPos
      );

      if (!validation.valid) {
        callback({ success: false, error: validation.error, errorCode: validation.errorCode });
        return;
      }

      // Execute attack
      const result = await combatService.executeAttack(
        gameId,
        socket.data.userId,
        attackerPos,
        targetPos
      );

      // Broadcast combat result to all players
      io.to(`game:${gameId}`).emit('game:combat_result', {
        attackerPos,
        targetPos,
        damageDealt: result.damageDealt,
        targetDestroyed: result.targetDestroyed,
        passiveTriggered: result.passiveTriggered,
        animation: {
          type: 'attack',
          from: attackerPos,
          to: targetPos,
          damage: result.damageDealt
        }
      });

      // Broadcast updated game state
      io.to(`game:${gameId}`).emit('game:state_update', result.gameStateAfter);

      callback({ success: true, result });

    } catch (error) {
      console.error('Combat error:', error);
      callback({ success: false, error: 'Internal server error' });
    }
  });

  // Get valid attack positions
  socket.on('game:get_attack_positions', async (data: AttackPositionRequest, callback) => {
    try {
      const { gameId, attackerPos } = data;
      const gameState = await gameStateService.getGameState(gameId);
      const attacker = gameState.players[socket.data.userId].board[attackerPos.y][attackerPos.x];

      if (!attacker) {
        callback({ success: false, error: 'No unit at position' });
        return;
      }

      const validPositions = rangeCalculator.getAttackablePositions(
        attacker,
        attackerPos,
        gameState.players
      );

      callback({ success: true, validPositions });
    } catch (error) {
      callback({ success: false, error: 'Failed to get attack positions' });
    }
  });
}
```

## üîå Integration Requirements

### Database Schema Enhancement
```sql
-- Add combat tracking to existing game_states
ALTER TABLE game_states ADD COLUMN combat_phase BOOLEAN DEFAULT FALSE;
ALTER TABLE game_states ADD COLUMN attacked_units JSONB DEFAULT '[]';

-- Add combat action logging
INSERT INTO game_actions (game_id, player_id, action_type, action_data)
VALUES ($1, $2, 'ATTACK', $3);
```

### Performance Requirements
- **Attack Validation**: < 50ms response time
- **Combat Calculation**: < 100ms for damage resolution
- **State Broadcasting**: < 100ms to all players in game
- **Memory Management**: Efficient cleanup of combat animations

## ‚úÖ Acceptance Criteria

### Functional Requirements
- [ ] Attack range validation working for all unit types (range 1, 2, 3)
- [ ] Line of sight calculation accurate for tactical positioning
- [ ] All three faction passive abilities implemented and triggered correctly
- [ ] Damage calculation accounts for attack/health modifiers
- [ ] Combat results broadcast in real-time to all players
- [ ] Unit death and removal handled properly

### Game Mechanics Requirements
- [ ] Humans: Ultimate Rampart passive triggers for completed lines
- [ ] Aliens: Evolutionary Adaptation reduces next summon cost on death
- [ ] Robots: Reanimation Protocols 30% resurrection chance working
- [ ] Turn-based combat restrictions (one attack per unit per turn)
- [ ] Simultaneous combat resolution for multiplayer fairness

### Integration Requirements
- [ ] Socket.io events integrate with existing infrastructure
- [ ] Game state persistence works with combat changes
- [ ] Error handling provides clear feedback for invalid attacks
- [ ] Performance requirements met under load testing

## üß™ Testing Strategy

### Unit Tests
```typescript
describe('Combat Logic Engine', () => {
  test('should validate attack range correctly', () => {
    const rangeCalc = new RangeCalculator();
    const positions = rangeCalc.getAttackablePositions(
      createTestCard({ range: 2 }),
      { x: 2, y: 1 },
      createTestBoard()
    );
    expect(positions).toHaveLength(3); // Expected valid targets
  });

  test('should apply faction passive abilities', () => {
    const factionManager = new FactionAbilityManager();
    const gameState = createTestGameState();

    const updated = factionManager.applyUltimateRampart(gameState, 'player1');

    expect(updated.players.player1.board[1][1].attack).toBe(4); // +2 from passive
  });

  test('should calculate damage correctly', () => {
    const combatService = new CombatService();
    const result = combatService.calculateDamage(
      createTestAttacker(3),
      createTestTarget(2),
      createTestGameState()
    );
    expect(result.finalDamage).toBe(3);
  });
});
```

### Integration Tests
```typescript
describe('Combat Socket Integration', () => {
  test('should handle attack event correctly', async () => {
    const { socket, mockCallback } = createTestSocket();

    socket.emit('game:attack', {
      gameId: 'test-game',
      attackerPos: { x: 1, y: 1 },
      targetPos: { x: 2, y: 1 }
    }, mockCallback);

    await waitFor(() => {
      expect(mockCallback).toHaveBeenCalledWith({ success: true });
    });
  });
});
```

## üìä Success Metrics
- **Combat Validation**: 100% accuracy for range and line-of-sight
- **Performance**: All operations < 100ms response time
- **Faction Balance**: Each passive ability triggers correctly in testing
- **Real-time Sync**: Combat results sync < 100ms across all clients

## üîó Dependencies & Integration
- **Requires**: 1.3A (Card System), 1.3B (Unit Placement)
- **Enables**: 1.3E (Combat UI), 1.3F (Turn Management)
- **Integrates With**: Existing Socket.io infrastructure, game state management

## üìù Notes
- **High Priority**: This is the core missing functionality for a playable game
- **Performance Critical**: Combat validation must be fast for good UX
- **Faction Balance**: Passive abilities need careful tuning and testing
- **Real-time Focus**: All combat results must sync immediately across players
- **Database Integration**: Use existing Prisma/PostgreSQL infrastructure

## üöÄ Implementation Strategy
1. **Day 1-2**: Core combat service and range validation
2. **Day 3**: Faction passive abilities implementation
3. **Day 4**: Socket.io event handlers and real-time sync
4. **Day 5**: Integration testing and performance optimization

This task is **CRITICAL** for game functionality and has **HIGH RISK** due to complex game logic requirements.