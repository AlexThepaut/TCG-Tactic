# Task 1.3D: Combat Logic Engine

**Phase**: 3 - Game Mechanics
**Priority**: Critical
**Estimated Time**: 4-5 days
**Dependencies**: Task 1.3A (Card System), Task 1.3B (Unit Placement), existing Socket.io infrastructure

## üéØ Objective

Implement server-side combat resolution with tactical depth, including attack range systems, faction passive abilities, simultaneous damage calculation, and real-time combat result broadcasting.

## üìã Requirements

### Functional Requirements

#### Combat Mechanics System
- **Attack Range Validation**: Calculate valid targets based on unit range (1, 2, 3 grid distances)
- **Simultaneous Combat**: Both units deal damage unless one dies first
- **Damage Resolution**: Apply damage and check for unit destruction
- **Status Effects**: Handle buffs, debuffs, and temporary effects
- **Combat Phases**: Pre-combat ‚Üí Combat ‚Üí Post-combat event handling

#### Range Calculation System
- **Grid Distance**: Calculate Manhattan distance for range validation
- **Line of Sight**: Direct line attacks (no obstacles in basic version)
- **Range Types**: Melee (range 1), Ranged (range 2-3), Special abilities
- **Target Validation**: Ensure targets are within range and valid
- **Multi-target Support**: Framework for future area-of-effect abilities

#### Faction Passive Abilities
- **Humans - "Ultimate Rampart"**: Complete lines get +2 ATK/+1 HP
- **Aliens - "Evolutionary Adaptation"**: Dead aliens reduce next summon cost by 1
- **Robots - "Reanimation Protocols"**: 30% chance to resurrect with 1 HP
- **Passive Triggers**: Activate during appropriate combat phases
- **Stack Management**: Handle multiple passive effects correctly

### Technical Requirements

#### Combat Engine Architecture
```typescript
interface CombatEngine {
  // Core combat methods
  validateAttack(gameId: string, attackerId: string, attackerPos: Position, targetPos: Position): ValidationResult;
  executeCombat(gameId: string, attackerPos: Position, targetPos: Position): Promise<CombatResult>;

  // Range and targeting
  calculateAttackRange(unit: PlacedCard, position: Position): Position[];
  getValidTargets(unit: PlacedCard, position: Position, gameState: GameState): Position[];

  // Faction passives
  applyPassiveEffects(gameState: GameState, phase: CombatPhase): GameState;
  checkLineBonus(playerData: PlayerData): LineBonus[];
  processUnitDeath(gameState: GameState, deadUnit: PlacedCard, position: Position): GameState;

  // Status effects
  applyStatusEffects(unit: PlacedCard, phase: CombatPhase): PlacedCard;
  resolveStatusExpiration(gameState: GameState): GameState;
}
```

#### Combat Data Models
```typescript
interface CombatResult {
  success: boolean;
  attackerDamage: number;
  defenderDamage: number;
  attackerDestroyed: boolean;
  defenderDestroyed: boolean;
  passiveEffects: PassiveEffect[];
  statusChanges: StatusChange[];
  gameState: GameState;
  combatLog: CombatLogEntry[];
}

interface CombatLogEntry {
  timestamp: Date;
  type: 'attack' | 'damage' | 'death' | 'passive' | 'resurrection';
  attacker?: CombatUnit;
  defender?: CombatUnit;
  damage?: number;
  effect?: string;
  description: string;
}

interface CombatUnit {
  cardId: string;
  position: Position;
  attack: number;
  health: number;
  currentHealth: number;
  range: number;
  statusEffects: StatusEffect[];
  faction: Faction;
}

interface StatusEffect {
  id: string;
  name: string;
  type: 'buff' | 'debuff' | 'neutral';
  duration: number; // -1 for permanent
  effects: {
    attack?: number;
    health?: number;
    range?: number;
    special?: string;
  };
  source: string; // What caused this effect
}

interface PassiveEffect {
  faction: Faction;
  type: 'line_bonus' | 'evolution_adaptation' | 'reanimation';
  description: string;
  value?: number;
  affected?: Position[];
}
```

## üèóÔ∏è Technical Architecture

### Core Combat Engine

#### CombatService Implementation
```typescript
class CombatService {
  private gameStateService: GameStateService;
  private cardService: CardService;
  private logger: GameLogger;

  async validateAttack(
    gameId: string,
    playerId: string,
    attackerPos: Position,
    targetPos: Position
  ): Promise<ValidationResult> {
    const gameState = await this.gameStateService.getGameState(gameId);
    if (!gameState) {
      return { valid: false, error: 'Game not found', errorCode: 'GAME_NOT_FOUND' };
    }

    // Validate turn and phase
    if (gameState.currentPlayerId !== playerId) {
      return { valid: false, error: 'Not your turn', errorCode: 'NOT_YOUR_TURN' };
    }

    if (gameState.phase !== 'actions') {
      return { valid: false, error: 'Not in action phase', errorCode: 'INVALID_PHASE' };
    }

    // Get units
    const playerData = this.getPlayerData(gameState, playerId);
    const attacker = playerData.board[attackerPos.y][attackerPos.x];
    const opponentData = this.getOpponentData(gameState, playerId);
    const defender = opponentData.board[targetPos.y][targetPos.x];

    if (!attacker) {
      return { valid: false, error: 'No unit at attacker position', errorCode: 'NO_ATTACKER' };
    }

    if (!defender) {
      return { valid: false, error: 'No target at position', errorCode: 'NO_TARGET' };
    }

    // Validate range
    const distance = this.calculateDistance(attackerPos, targetPos);
    if (distance > attacker.range) {
      return { valid: false, error: 'Target out of range', errorCode: 'OUT_OF_RANGE' };
    }

    return { valid: true };
  }

  async executeCombat(
    gameId: string,
    playerId: string,
    attackerPos: Position,
    targetPos: Position
  ): Promise<CombatResult> {
    // Validate attack first
    const validation = await this.validateAttack(gameId, playerId, attackerPos, targetPos);
    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const gameState = await this.gameStateService.getGameState(gameId);
    const playerData = this.getPlayerData(gameState, playerId);
    const opponentData = this.getOpponentData(gameState, playerId);

    const attacker = playerData.board[attackerPos.y][attackerPos.x]!;
    const defender = opponentData.board[targetPos.y][targetPos.x]!;

    // Apply pre-combat effects
    const preAttacker = this.applyPreCombatEffects(attacker, gameState, playerId);
    const preDefender = this.applyPreCombatEffects(defender, gameState, this.getOpponentId(gameState, playerId));

    // Calculate damage
    const attackerDamage = this.calculateDamage(preAttacker, preDefender);
    const defenderDamage = this.calculateDamage(preDefender, preAttacker);

    // Apply damage simultaneously
    const attackerNewHealth = Math.max(0, preAttacker.currentHealth - defenderDamage);
    const defenderNewHealth = Math.max(0, preDefender.currentHealth - attackerDamage);

    const attackerDestroyed = attackerNewHealth <= 0;
    const defenderDestroyed = defenderNewHealth <= 0;

    // Update units
    if (!attackerDestroyed) {
      attacker.currentHealth = attackerNewHealth;
    }
    if (!defenderDestroyed) {
      defender.currentHealth = defenderNewHealth;
    }

    // Handle unit destruction
    if (attackerDestroyed) {
      playerData.board[attackerPos.y][attackerPos.x] = null;
    }
    if (defenderDestroyed) {
      opponentData.board[targetPos.y][targetPos.x] = null;
    }

    // Apply post-combat effects (faction passives)
    let updatedGameState = { ...gameState };
    updatedGameState = this.applyPostCombatEffects(updatedGameState, {
      attackerDestroyed,
      defenderDestroyed,
      attackerPos,
      targetPos,
      attacker,
      defender
    });

    // Save updated game state
    await this.gameStateService.saveGameState(updatedGameState);

    // Create combat log
    const combatLog = this.createCombatLog({
      attacker: preAttacker,
      defender: preDefender,
      attackerDamage,
      defenderDamage,
      attackerDestroyed,
      defenderDestroyed,
      attackerPos,
      targetPos
    });

    return {
      success: true,
      attackerDamage,
      defenderDamage,
      attackerDestroyed,
      defenderDestroyed,
      passiveEffects: this.getPassiveEffects(updatedGameState),
      statusChanges: [],
      gameState: updatedGameState,
      combatLog
    };
  }

  private calculateDistance(pos1: Position, pos2: Position): number {
    // Manhattan distance for grid-based combat
    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
  }

  private calculateDamage(attacker: PlacedCard, defender: PlacedCard): number {
    let damage = attacker.attack;

    // Apply status effects
    attacker.statusEffects.forEach(effect => {
      if (effect.effects.attack) {
        damage += effect.effects.attack;
      }
    });

    // Apply defender damage reduction
    defender.statusEffects.forEach(effect => {
      if (effect.effects.special === 'damage_reduction') {
        damage = Math.max(1, damage - (effect.effects.attack || 0));
      }
    });

    return Math.max(0, damage);
  }
}
```

### Faction Passive Implementations

#### Human Passive - Ultimate Rampart
```typescript
private checkLineBonus(playerData: PlayerData): LineBonus[] {
  const bonuses: LineBonus[] = [];
  const board = playerData.board;

  // Check horizontal lines
  for (let y = 0; y < 3; y++) {
    let lineComplete = true;
    const positions: Position[] = [];

    for (let x = 0; x < 5; x++) {
      if (FACTION_FORMATIONS.humans[y][x]) {
        if (board[y][x] === null) {
          lineComplete = false;
          break;
        }
        positions.push({ x, y });
      }
    }

    if (lineComplete && positions.length > 0) {
      bonuses.push({
        type: 'line_complete',
        positions,
        attackBonus: 2,
        healthBonus: 1
      });
    }
  }

  return bonuses;
}

private applyLineBonus(playerData: PlayerData, bonuses: LineBonus[]): void {
  bonuses.forEach(bonus => {
    bonus.positions.forEach(pos => {
      const unit = playerData.board[pos.y][pos.x];
      if (unit) {
        // Add status effect for line bonus
        const existingBonus = unit.statusEffects.find(e => e.id === 'line_bonus');
        if (!existingBonus) {
          unit.statusEffects.push({
            id: 'line_bonus',
            name: 'Ultimate Rampart',
            type: 'buff',
            duration: -1, // Permanent while line is complete
            effects: {
              attack: bonus.attackBonus,
              health: bonus.healthBonus
            },
            source: 'human_passive'
          });
        }
      }
    });
  });
}
```

#### Alien Passive - Evolutionary Adaptation
```typescript
private processAlienDeath(gameState: GameState, deadUnit: PlacedCard, playerId: string): GameState {
  if (deadUnit.faction !== 'aliens') return gameState;

  const playerData = this.getPlayerData(gameState, playerId);

  // Add evolution adaptation effect
  const existingEffect = playerData.statusEffects?.find(e => e.id === 'evolution_adaptation');
  if (existingEffect) {
    // Increase the stacks
    existingEffect.effects.special = String(Number(existingEffect.effects.special || '0') + 1);
  } else {
    playerData.statusEffects = playerData.statusEffects || [];
    playerData.statusEffects.push({
      id: 'evolution_adaptation',
      name: 'Evolutionary Adaptation',
      type: 'buff',
      duration: -1,
      effects: {
        special: '1' // Number of cost reductions available
      },
      source: 'alien_passive'
    });
  }

  return gameState;
}

private applyEvolutionReduction(playerData: PlayerData, cardCost: number): number {
  const effect = playerData.statusEffects?.find(e => e.id === 'evolution_adaptation');
  if (!effect) return cardCost;

  const reductions = Number(effect.effects.special || '0');
  if (reductions > 0) {
    // Use one reduction
    effect.effects.special = String(reductions - 1);

    // Remove effect if no reductions left
    if (reductions === 1) {
      playerData.statusEffects = playerData.statusEffects?.filter(e => e.id !== 'evolution_adaptation');
    }

    return Math.max(1, cardCost - 1);
  }

  return cardCost;
}
```

#### Robot Passive - Reanimation Protocols
```typescript
private processRobotDeath(gameState: GameState, deadUnit: PlacedCard, position: Position, playerId: string): GameState {
  if (deadUnit.faction !== 'robots') return gameState;

  // 30% chance to resurrect with 1 HP
  const resurrectionChance = Math.random();
  if (resurrectionChance <= 0.3) {
    const playerData = this.getPlayerData(gameState, playerId);

    // Resurrect the unit
    const resurrectedUnit = { ...deadUnit };
    resurrectedUnit.currentHealth = 1;
    resurrectedUnit.statusEffects.push({
      id: 'reanimated',
      name: 'Reanimated',
      type: 'neutral',
      duration: -1,
      effects: {},
      source: 'robot_passive'
    });

    playerData.board[position.y][position.x] = resurrectedUnit;

    // Log resurrection
    this.logger.logEvent(gameState.gameId, {
      type: 'resurrection',
      unit: resurrectedUnit,
      position,
      description: 'Unit resurrected by Reanimation Protocols'
    });
  }

  return gameState;
}
```

## üîå Socket.io Integration

### Combat Events
```typescript
// Client to Server Events
interface ClientToServerEvents {
  'game:attack': (data: AttackRequest, callback: (response: CombatResponse) => void) => void;
}

interface AttackRequest {
  gameId: string;
  attackerPosition: Position;
  targetPosition: Position;
}

interface CombatResponse {
  success: boolean;
  result?: CombatResult;
  error?: string;
  errorCode?: string;
}

// Server to Client Events
interface ServerToClientEvents {
  'game:combat_result': (result: CombatResult) => void;
  'game:passive_triggered': (effect: PassiveEffect) => void;
  'game:unit_destroyed': (position: Position, unit: PlacedCard) => void;
  'game:unit_resurrected': (position: Position, unit: PlacedCard) => void;
}
```

### Socket Event Handlers
```typescript
socket.on('game:attack', async (data: AttackRequest, callback) => {
  try {
    const result = await combatService.executeCombat(
      data.gameId,
      socket.userId,
      data.attackerPosition,
      data.targetPosition
    );

    // Send response to attacking player
    callback({
      success: true,
      result
    });

    // Broadcast combat result to all players in game
    socket.to(data.gameId).emit('game:combat_result', result);
    socket.emit('game:combat_result', result);

    // Broadcast specific events for better UI feedback
    if (result.attackerDestroyed) {
      socket.to(data.gameId).emit('game:unit_destroyed', data.attackerPosition, result.combatLog[0].attacker);
    }
    if (result.defenderDestroyed) {
      socket.to(data.gameId).emit('game:unit_destroyed', data.targetPosition, result.combatLog[0].defender);
    }

    // Broadcast passive effects
    result.passiveEffects.forEach(effect => {
      socket.to(data.gameId).emit('game:passive_triggered', effect);
      socket.emit('game:passive_triggered', effect);
    });

  } catch (error) {
    console.error('Combat error:', error);
    callback({
      success: false,
      error: error.message,
      errorCode: 'COMBAT_ERROR'
    });
  }
});
```

## ‚úÖ Acceptance Criteria

### Combat Mechanics
- [ ] Attack range validation works for all range types (1-3)
- [ ] Simultaneous damage resolution prevents timing issues
- [ ] Unit destruction properly removes units from board
- [ ] Status effects apply and expire correctly
- [ ] Combat validation prevents invalid attacks

### Faction Passives
- [ ] Human line bonus applies to complete formations
- [ ] Alien evolution adaptation reduces next summon cost
- [ ] Robot reanimation has 30% success rate
- [ ] All passives trigger at appropriate times
- [ ] Passive effects stack and interact correctly

### Real-time Synchronization
- [ ] Combat results broadcast to all players <100ms
- [ ] Game state remains synchronized after combat
- [ ] Error handling provides clear feedback
- [ ] No desynchronization during concurrent actions

### Performance & Quality
- [ ] Combat calculations complete <50ms
- [ ] Memory usage stable during extended gameplay
- [ ] All combat scenarios logged for debugging
- [ ] Comprehensive test coverage >90%

## üß™ Testing Strategy

### Unit Tests
- Range calculation accuracy
- Damage calculation logic
- Faction passive implementations
- Status effect management
- Combat validation rules

### Integration Tests
- Socket.io event handling
- Database state persistence
- Real-time broadcasting
- Error handling scenarios

### Game Logic Tests
- All faction passive combinations
- Edge cases (simultaneous destruction)
- Complex status effect interactions
- Performance under concurrent attacks

### Balance Tests
- Faction passive balance validation
- Combat outcome distribution
- Performance metrics analysis
- Player experience validation

## üì¶ Deliverables

1. **CombatService**: Complete combat engine with all mechanics
2. **Passive Systems**: All three faction passive implementations
3. **Socket.io Integration**: Real-time combat event handling
4. **Database Schema**: Combat logging and state persistence
5. **Status Effects**: Framework for buffs, debuffs, and temporary effects
6. **Tests**: Comprehensive test suite with combat scenarios
7. **Documentation**: Combat mechanics and API documentation
8. **Performance Analysis**: Combat engine performance metrics

## üöÄ Implementation Notes

### Combat Balance
- Ensure simultaneous combat prevents first-strike advantages
- Balance faction passives for competitive gameplay
- Provide clear feedback for all combat interactions
- Log all combat for future balance analysis

### Performance Optimization
- Cache formation data and range calculations
- Batch multiple status effect applications
- Optimize database queries for game state updates
- Use efficient algorithms for range calculations

### Future Extensibility
- Design status effect system for future card abilities
- Support for area-of-effect attacks
- Framework for complex ability interactions
- Expandable combat logging for AI analysis

This combat engine provides the tactical depth necessary for engaging TCG Tactique gameplay while maintaining the performance and reliability required for real-time multiplayer combat.