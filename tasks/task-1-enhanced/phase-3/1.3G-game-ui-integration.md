# Task 1.3G: Game UI Integration

**Phase**: 3 - Game Mechanics
**Priority**: High
**Estimated Time**: 5-6 days
**Dependencies**: All previous Phase 3 tasks (1.3A-1.3F), Phase 2 frontend infrastructure

## üéØ Objective

Integrate all game mechanics into a cohesive, professional user interface that provides seamless gameplay experience with intuitive controls, clear status displays, comprehensive error handling, and polished game end states.

## üìã Requirements

### Functional Requirements

#### Complete Game Layout
- **Dual Board Display**: Both player and opponent boards with clear differentiation
- **Interactive Hand**: Card hand with drag/drop and resource cost indicators
- **Status Panels**: Turn indicators, phase displays, resource counters, deck counts
- **Action Areas**: Combat controls, turn management, game options
- **Responsive Design**: Optimal layout for desktop, tablet, and mobile devices

#### Integrated Game Flow
- **Seamless Transitions**: Smooth flow between placement, combat, and turn phases
- **State Consistency**: All UI components reflect current game state accurately
- **Real-time Updates**: Instant synchronization of all game changes
- **Mode Switching**: Intuitive transitions between different interaction modes
- **Context Awareness**: UI adapts to current game phase and player capabilities

#### Comprehensive Status Display
- **Game Information**: Current turn, phase, active player
- **Resource Management**: Void Echoes display with spending preview
- **Deck Status**: Cards remaining, hand count, draw pile indicator
- **Victory Progress**: Progress toward victory conditions (future expansion)
- **Connection Status**: Network connection and sync indicators

#### Error Handling & Feedback
- **User-Friendly Messages**: Clear error explanations for all failure scenarios
- **Visual Feedback**: Immediate response to user actions
- **Loading States**: Progress indicators for network operations
- **Retry Mechanisms**: Options to retry failed actions
- **Graceful Degradation**: Fallback behavior for connection issues

#### Game End States
- **Victory Screens**: Celebratory victory announcement with game statistics
- **Defeat Screens**: Graceful defeat handling with replay options
- **Game Summary**: Turn count, actions taken, key moments
- **Navigation Options**: Return to menu, play again, view replay
- **Statistics Display**: Performance metrics and achievements

### Technical Requirements

#### Main Game Interface Architecture
```typescript
interface GameInterfaceProps {
  gameId: string;
  userId: string;
  initialGameState?: GameState;
}

interface GameUIState {
  gameState: GameState | null;
  selectedCard: Card | null;
  selectedPosition: Position | null;
  interactionMode: 'placement' | 'combat' | 'viewing' | 'ended';
  isLoading: boolean;
  error: string | null;
  notifications: Notification[];
}

interface GameLayoutConfig {
  showOpponentCards: boolean;
  enableAnimations: boolean;
  showAdvancedStats: boolean;
  mobileOptimized: boolean;
  accessibilityMode: boolean;
}
```

## üèóÔ∏è Technical Architecture

### Main Game Interface Component

#### GameInterface Implementation
```typescript
const GameInterface: React.FC<GameInterfaceProps> = ({ gameId, userId, initialGameState }) => {
  const [uiState, setUIState] = useState<GameUIState>({
    gameState: initialGameState || null,
    selectedCard: null,
    selectedPosition: null,
    interactionMode: 'viewing',
    isLoading: false,
    error: null,
    notifications: []
  });

  // Hooks for game functionality
  const { socket, isConnected } = useSocket();
  const {
    gameState,
    isMyTurn,
    currentPlayer,
    opponent
  } = useGameSocket(gameId);

  const {
    placeCard,
    attack,
    endTurn
  } = useGameActions(gameId);

  const {
    turnState,
    endTurn: endTurnAction
  } = useTurnManagement(gameId);

  // UI state management
  useEffect(() => {
    if (gameState) {
      setUIState(prev => ({
        ...prev,
        gameState,
        interactionMode: gameState.gameOver ? 'ended' :
                        isMyTurn ? 'placement' : 'viewing'
      }));
    }
  }, [gameState, isMyTurn]);

  // Main interaction handlers
  const handleCardPlace = async (cardId: string, position: Position) => {
    setUIState(prev => ({ ...prev, isLoading: true }));

    try {
      await placeCard(cardId, position);
      addNotification('Card placed successfully', 'success');

      // Clear selection
      setUIState(prev => ({
        ...prev,
        selectedCard: null,
        selectedPosition: null,
        isLoading: false
      }));
    } catch (error) {
      handleError(error as Error);
    }
  };

  const handleAttack = async (attackerPos: Position, targetPos: Position) => {
    setUIState(prev => ({ ...prev, isLoading: true }));

    try {
      await attack(attackerPos, targetPos);
      addNotification('Attack executed', 'success');

      setUIState(prev => ({ ...prev, isLoading: false }));
    } catch (error) {
      handleError(error as Error);
    }
  };

  const handleEndTurn = async () => {
    setUIState(prev => ({ ...prev, isLoading: true }));

    try {
      await endTurnAction();
      addNotification('Turn ended', 'info');

      setUIState(prev => ({
        ...prev,
        interactionMode: 'viewing',
        isLoading: false
      }));
    } catch (error) {
      handleError(error as Error);
    }
  };

  const handleError = (error: Error) => {
    setUIState(prev => ({
      ...prev,
      error: error.message,
      isLoading: false
    }));
    addNotification(error.message, 'error');
  };

  const addNotification = (message: string, type: 'success' | 'error' | 'info') => {
    const notification: Notification = {
      id: Date.now().toString(),
      message,
      type,
      timestamp: new Date()
    };

    setUIState(prev => ({
      ...prev,
      notifications: [...prev.notifications, notification]
    }));

    // Auto-remove after 5 seconds
    setTimeout(() => {
      setUIState(prev => ({
        ...prev,
        notifications: prev.notifications.filter(n => n.id !== notification.id)
      }));
    }, 5000);
  };

  // Render game end screen if game is over
  if (uiState.gameState?.gameOver) {
    return (
      <GameEndScreen
        gameState={uiState.gameState}
        userId={userId}
        onNewGame={() => window.location.href = '/game'}
        onReturnToMenu={() => window.location.href = '/'}
      />
    );
  }

  // Main game interface
  return (
    <div className="game-interface">
      {/* Connection Status */}
      <ConnectionStatus isConnected={isConnected} />

      {/* Main Game Area */}
      <div className="game-main">
        {/* Opponent Area */}
        <div className="opponent-area">
          <PlayerInfo
            player={opponent}
            isCurrentPlayer={false}
            turnState={turnState}
          />
          <GameBoard
            gameState={uiState.gameState}
            player={opponent}
            isInteractive={false}
            showCards={false}
          />
        </div>

        {/* Center Game Info */}
        <div className="game-center">
          <TurnIndicator
            gameState={uiState.gameState}
            currentUserId={userId}
          />

          <PhaseIndicator
            currentPhase={uiState.gameState?.phase}
            isMyTurn={isMyTurn}
          />

          {/* Game Actions */}
          {isMyTurn && uiState.gameState?.phase === 'actions' && (
            <div className="game-actions">
              <button
                onClick={handleEndTurn}
                disabled={uiState.isLoading}
                className="end-turn-button"
              >
                {uiState.isLoading ? 'Ending Turn...' : 'End Turn'}
              </button>
            </div>
          )}
        </div>

        {/* Player Area */}
        <div className="player-area">
          <PlayerInfo
            player={currentPlayer}
            isCurrentPlayer={true}
            turnState={turnState}
          />

          {/* Interactive Game Board */}
          <GameBoard
            gameState={uiState.gameState}
            player={currentPlayer}
            isInteractive={isMyTurn}
            selectedCard={uiState.selectedCard}
            selectedPosition={uiState.selectedPosition}
            interactionMode={uiState.interactionMode}
            onCardPlace={handleCardPlace}
            onAttack={handleAttack}
            onCardSelect={(card) => setUIState(prev => ({ ...prev, selectedCard: card }))}
            onPositionSelect={(pos) => setUIState(prev => ({ ...prev, selectedPosition: pos }))}
          />

          {/* Player Hand */}
          <Hand
            cards={currentPlayer?.hand || []}
            selectedCard={uiState.selectedCard}
            playerResources={currentPlayer?.resources || 0}
            isPlayerTurn={isMyTurn}
            isActionsPhase={uiState.gameState?.phase === 'actions'}
            onCardSelect={(card) => setUIState(prev => ({ ...prev, selectedCard: card }))}
            onCardPlace={handleCardPlace}
          />
        </div>
      </div>

      {/* UI Overlays */}
      <LoadingOverlay isVisible={uiState.isLoading} />
      <NotificationCenter notifications={uiState.notifications} />
      <ErrorDisplay error={uiState.error} onDismiss={() => setUIState(prev => ({ ...prev, error: null }))} />
    </div>
  );
};
```

### Integrated Component System

#### PlayerInfo Component
```typescript
const PlayerInfo: React.FC<PlayerInfoProps> = ({
  player,
  isCurrentPlayer,
  turnState
}) => {
  return (
    <div className={`player-info ${isCurrentPlayer ? 'current-player' : 'opponent'}`}>
      <div className="player-header">
        <h3>{player.username}</h3>
        <div className={`faction-badge faction-${player.faction}`}>
          {player.faction.toUpperCase()}
        </div>
      </div>

      <div className="player-stats">
        {/* Resources */}
        <ResourceDisplay
          resources={player.resources}
          maxResources={player.maxResources}
          isCurrentPlayer={isCurrentPlayer}
        />

        {/* Deck Info */}
        <div className="deck-info">
          <div className="deck-count">
            <span className="count">{player.deck.length}</span>
            <span className="label">Deck</span>
          </div>
          <div className="hand-count">
            <span className="count">{player.hand.length}</span>
            <span className="label">Hand</span>
          </div>
        </div>

        {/* Turn Indicator */}
        {turnState && (
          <div className="turn-status">
            {turnState.currentPlayer === player.id ? (
              <span className="active-turn">Active Turn</span>
            ) : (
              <span className="waiting">Waiting</span>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
```

#### Game End Screen
```typescript
const GameEndScreen: React.FC<GameEndScreenProps> = ({
  gameState,
  userId,
  onNewGame,
  onReturnToMenu
}) => {
  const isWinner = gameState.winner === userId;
  const winCondition = getWinConditionDescription(gameState);

  return (
    <div className="game-end-screen">
      <div className="game-end-modal">
        {/* Victory/Defeat Header */}
        <div className={`game-result ${isWinner ? 'victory' : 'defeat'}`}>
          <h1>{isWinner ? 'üèÜ Victory!' : 'üíÄ Defeat'}</h1>
          <p>{winCondition}</p>
        </div>

        {/* Game Statistics */}
        <div className="game-stats">
          <h3>Game Summary</h3>
          <div className="stats-grid">
            <div className="stat">
              <span className="value">{gameState.turn}</span>
              <span className="label">Turns</span>
            </div>
            <div className="stat">
              <span className="value">{calculateGameDuration(gameState)}</span>
              <span className="label">Duration</span>
            </div>
            <div className="stat">
              <span className="value">{countPlayerActions(gameState, userId)}</span>
              <span className="label">Actions</span>
            </div>
            <div className="stat">
              <span className="value">{countUnitsPlaced(gameState, userId)}</span>
              <span className="label">Units Placed</span>
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="game-end-actions">
          <button onClick={onNewGame} className="primary-button">
            Play Again
          </button>
          <button onClick={onReturnToMenu} className="secondary-button">
            Return to Menu
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### Notification System
```typescript
const NotificationCenter: React.FC<NotificationCenterProps> = ({ notifications }) => {
  return (
    <div className="notification-center">
      {notifications.map(notification => (
        <Notification
          key={notification.id}
          notification={notification}
        />
      ))}
    </div>
  );
};

const Notification: React.FC<NotificationProps> = ({ notification }) => {
  return (
    <div className={`notification notification-${notification.type}`}>
      <div className="notification-icon">
        {getNotificationIcon(notification.type)}
      </div>
      <div className="notification-content">
        <p>{notification.message}</p>
        <span className="notification-time">
          {formatTime(notification.timestamp)}
        </span>
      </div>
    </div>
  );
};
```

## üé® Visual Design & Styling

### Main Layout CSS
```css
/* Game Interface Layout */
.game-interface {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  color: white;
  overflow: hidden;
}

.game-main {
  display: flex;
  flex-direction: column;
  flex: 1;
  gap: 1rem;
  padding: 1rem;
}

/* Player Areas */
.opponent-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-bottom: 2px solid rgba(255, 255, 255, 0.1);
  padding-bottom: 1rem;
}

.player-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding-top: 1rem;
}

.game-center {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2rem;
  padding: 1rem 0;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  margin: 1rem 0;
}

/* Player Info */
.player-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  margin-bottom: 1rem;
}

.player-info.current-player {
  background: rgba(59, 130, 246, 0.15);
  border: 1px solid rgba(59, 130, 246, 0.3);
}

.player-header {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.faction-badge {
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: bold;
}

.faction-humans { background: #3b82f6; }
.faction-aliens { background: #10b981; }
.faction-robots { background: #ef4444; }

.player-stats {
  display: flex;
  align-items: center;
  gap: 2rem;
}

/* Resource Display */
.resource-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

.resource-counter {
  font-size: 1.5rem;
  font-weight: bold;
}

.resource-orbs {
  display: flex;
  gap: 0.25rem;
}

.resource-orb {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.resource-orb.filled {
  background: #3b82f6;
  box-shadow: 0 0 8px #3b82f6;
}

.resource-orb.available {
  background: rgba(59, 130, 246, 0.3);
}

.resource-orb.locked {
  background: rgba(255, 255, 255, 0.1);
}

/* Turn Indicator */
.turn-indicator {
  text-align: center;
  padding: 1rem;
}

.turn-indicator.my-turn {
  color: #10b981;
}

.turn-indicator.opponent-turn {
  color: #ef4444;
}

.phase-indicator {
  display: flex;
  gap: 1rem;
}

.phase {
  padding: 0.5rem 1rem;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.1);
  font-size: 0.875rem;
}

.phase.active {
  background: #10b981;
  color: white;
}

.phase.completed {
  background: rgba(16, 185, 129, 0.3);
  color: #10b981;
}

/* Game Actions */
.game-actions {
  display: flex;
  gap: 1rem;
}

.end-turn-button {
  padding: 0.75rem 2rem;
  background: #10b981;
  color: white;
  border: none;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.end-turn-button:hover {
  background: #059669;
  transform: translateY(-1px);
}

.end-turn-button:disabled {
  background: #6b7280;
  cursor: not-allowed;
  transform: none;
}

/* Game End Screen */
.game-end-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.game-end-modal {
  background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
  padding: 3rem;
  border-radius: 16px;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
  text-align: center;
  max-width: 500px;
  width: 90%;
}

.game-result.victory {
  color: #10b981;
}

.game-result.defeat {
  color: #ef4444;
}

.game-result h1 {
  font-size: 3rem;
  margin-bottom: 1rem;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  margin: 2rem 0;
}

.stat {
  text-align: center;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.stat .value {
  display: block;
  font-size: 2rem;
  font-weight: bold;
  color: #10b981;
}

.stat .label {
  font-size: 0.875rem;
  opacity: 0.7;
}

.game-end-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 2rem;
}

.primary-button {
  padding: 1rem 2rem;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.secondary-button {
  padding: 1rem 2rem;
  background: transparent;
  color: white;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

/* Notifications */
.notification-center {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 900;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.notification {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  animation: slideIn 0.3s ease-out;
}

.notification-success {
  border-left: 4px solid #10b981;
}

.notification-error {
  border-left: 4px solid #ef4444;
}

.notification-info {
  border-left: 4px solid #3b82f6;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Connection Status */
.connection-status {
  position: fixed;
  top: 1rem;
  left: 1rem;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.875rem;
  z-index: 800;
}

.connection-status.connected {
  background: rgba(16, 185, 129, 0.2);
  color: #10b981;
  border: 1px solid rgba(16, 185, 129, 0.3);
}

.connection-status.disconnected {
  background: rgba(239, 68, 68, 0.2);
  color: #ef4444;
  border: 1px solid rgba(239, 68, 68, 0.3);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 950;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top: 4px solid #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive Design */
@media (max-width: 768px) {
  .game-main {
    padding: 0.5rem;
  }

  .game-center {
    flex-direction: column;
    gap: 1rem;
  }

  .player-stats {
    flex-direction: column;
    gap: 1rem;
  }

  .stats-grid {
    grid-template-columns: 1fr;
  }

  .game-end-actions {
    flex-direction: column;
  }
}
```

## ‚úÖ Acceptance Criteria

### User Interface
- [ ] Complete game layout with all essential components
- [ ] Responsive design works on desktop, tablet, and mobile
- [ ] Intuitive navigation between game modes
- [ ] Professional visual design with consistent styling
- [ ] Accessibility features (ARIA labels, keyboard navigation)

### Game Integration
- [ ] All Phase 3 mechanics work together seamlessly
- [ ] Real-time synchronization across all game elements
- [ ] State consistency maintained throughout gameplay
- [ ] Error handling provides clear user feedback
- [ ] Loading states and transitions are smooth

### User Experience
- [ ] Clear status indicators for all game information
- [ ] Intuitive controls for all game actions
- [ ] Immediate visual feedback for user interactions
- [ ] Comprehensive game end experience
- [ ] Professional-quality UI polish

### Performance & Quality
- [ ] Interface remains responsive during intensive gameplay
- [ ] Memory usage stable during extended sessions
- [ ] Cross-browser compatibility validated
- [ ] Mobile performance optimized

## üß™ Testing Strategy

### Integration Tests
- Complete gameplay scenarios
- All game mechanics working together
- Real-time synchronization
- Error handling across components

### UI/UX Tests
- Component interaction testing
- Responsive design validation
- Accessibility compliance
- Cross-browser compatibility

### Performance Tests
- Interface responsiveness
- Memory usage monitoring
- Animation performance
- Mobile optimization

### User Testing
- Complete game experience
- Usability and intuitiveness
- Visual design feedback
- Mobile vs desktop experience

## üì¶ Deliverables

1. **GameInterface Component**: Complete integrated game UI
2. **Component System**: All supporting UI components
3. **Styling System**: Complete responsive CSS design
4. **Error Handling**: Comprehensive error management
5. **Game End Flow**: Victory/defeat screens and navigation
6. **Notification System**: Real-time user feedback
7. **Tests**: Complete UI integration test suite
8. **Documentation**: UI usage and customization guides

## üöÄ Implementation Notes

### Performance Optimization
- Component memoization for expensive renders
- Efficient state management patterns
- Optimized re-render strategies
- Hardware-accelerated animations

### Accessibility Standards
- WCAG 2.1 AA compliance
- Screen reader compatibility
- Keyboard navigation support
- High contrast mode support

### Mobile Optimization
- Touch-friendly interface design
- Gesture recognition integration
- Performance optimization for mobile devices
- Landscape orientation optimization

This final integration task brings together all Phase 3 mechanics into a polished, professional gaming experience that provides the complete foundation for TCG Tactique gameplay.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Create Task 1.3A: Card System Foundation specification", "status": "completed", "activeForm": "Creating Task 1.3A specification"}, {"content": "Create Task 1.3B: Unit Placement Backend specification", "status": "completed", "activeForm": "Creating Task 1.3B specification"}, {"content": "Create Task 1.3C: Drag & Drop Interface specification", "status": "completed", "activeForm": "Creating Task 1.3C specification"}, {"content": "Create Task 1.3D: Combat Logic Engine specification", "status": "completed", "activeForm": "Creating Task 1.3D specification"}, {"content": "Create Task 1.3E: Combat User Interface specification", "status": "completed", "activeForm": "Creating Task 1.3E specification"}, {"content": "Create Task 1.3F: Turn Management System specification", "status": "completed", "activeForm": "Creating Task 1.3F specification"}, {"content": "Create Task 1.3G: Game UI Integration specification", "status": "completed", "activeForm": "Creating Task 1.3G specification"}]