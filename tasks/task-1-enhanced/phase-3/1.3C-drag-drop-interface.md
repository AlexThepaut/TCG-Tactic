# Task 1.3C: Drag & Drop Interface

**Phase**: 3 - Game Mechanics
**Priority**: High
**Estimated Time**: 4-5 days
**Dependencies**: Task 1.3B (Unit Placement Backend), Phase 2 frontend infrastructure

## üéØ Objective

Create an intuitive frontend interface for card placement with smooth drag & drop functionality, visual feedback for placement validation, and seamless integration with the backend placement system.

## üìã Requirements

### Functional Requirements

#### Hand Management System
- **Card Display**: Show player's hand with up to 7 cards
- **Card Information**: Display attack, health, cost, and abilities
- **Card Selection**: Highlight selected card with visual feedback
- **Hand Organization**: Automatic card arrangement and spacing
- **Responsive Layout**: Adapt to different screen sizes and orientations

#### Drag & Drop Mechanics
- **Smooth Dragging**: Fluid card movement following cursor/touch
- **Drop Zones**: Visual indication of valid placement areas
- **Placement Preview**: Ghost card preview at valid positions
- **Invalid Feedback**: Clear visual indication for invalid placements
- **Gesture Support**: Touch-friendly for mobile and tablet devices

#### Visual Feedback System
- **Formation Display**: Show faction-specific playable positions
- **Position Validation**: Green highlighting for valid positions
- **Error Indication**: Red highlighting for invalid positions
- **Resource Validation**: Visual cost/resource comparison
- **Animation Feedback**: Smooth transitions and visual confirmations

#### Game Board Interface
- **Grid Visualization**: Clear 3√ó5 grid representation
- **Unit Display**: Show placed units with stats and status
- **Opponent Board**: Read-only view of opponent's board
- **Position Markers**: Clear grid position indicators
- **Faction Theming**: Visual distinction between faction areas

### Technical Requirements

#### Component Architecture
```typescript
// Main game board component
interface GameBoardProps {
  gameState: GameState;
  currentPlayer: Player;
  onCardPlace: (cardId: string, position: Position) => Promise<void>;
  onCardSelect: (cardId: string) => void;
  selectedCard?: Card;
  isPlayerTurn: boolean;
}

// Hand component
interface HandProps {
  cards: Card[];
  selectedCard?: Card;
  onCardSelect: (cardId: string) => void;
  onDragStart: (cardId: string, event: DragEvent) => void;
  playerResources: number;
  isPlayerTurn: boolean;
}

// Grid cell component
interface GridCellProps {
  position: Position;
  unit?: PlacedCard;
  isValidDrop: boolean;
  isPlayerSide: boolean;
  faction: Faction;
  onDrop: (cardId: string, position: Position) => void;
  onDragOver: (event: DragEvent) => void;
}
```

#### Drag & Drop Implementation
```typescript
// Drag and drop hook
interface DragDropState {
  draggedCard: Card | null;
  dragPreview: Position | null;
  validPositions: Position[];
  isDragging: boolean;
}

interface UseDragDropReturn {
  dragDropState: DragDropState;
  startDrag: (card: Card) => void;
  endDrag: () => void;
  updateDragPosition: (position: Position) => void;
  handleDrop: (position: Position) => Promise<void>;
}

// Touch support for mobile
interface TouchDragState {
  startPosition: { x: number; y: number };
  currentPosition: { x: number; y: number };
  isDragging: boolean;
  touchTarget: Element | null;
}
```

## üèóÔ∏è Technical Architecture

### React Components

#### GameBoard Component
```typescript
const GameBoard: React.FC<GameBoardProps> = ({
  gameState,
  currentPlayer,
  onCardPlace,
  selectedCard,
  isPlayerTurn
}) => {
  const { dragDropState, startDrag, endDrag, handleDrop } = useDragDrop();

  return (
    <div className="game-board">
      {/* Opponent Board */}
      <div className="opponent-board">
        <PlayerGrid
          playerData={gameState.opponent}
          isInteractive={false}
          faction={gameState.opponent.faction}
        />
      </div>

      {/* Current Player Board */}
      <div className="player-board">
        <PlayerGrid
          playerData={currentPlayer}
          isInteractive={isPlayerTurn}
          faction={currentPlayer.faction}
          onDrop={handleDrop}
          validPositions={dragDropState.validPositions}
          dragPreview={dragDropState.dragPreview}
        />
      </div>

      {/* Player Hand */}
      <Hand
        cards={currentPlayer.hand}
        selectedCard={selectedCard}
        onDragStart={startDrag}
        playerResources={currentPlayer.resources}
        isPlayerTurn={isPlayerTurn}
      />
    </div>
  );
};
```

#### Hand Component
```typescript
const Hand: React.FC<HandProps> = ({
  cards,
  selectedCard,
  onDragStart,
  playerResources,
  isPlayerTurn
}) => {
  return (
    <div className="hand-container">
      <div className="hand-cards">
        {cards.map((card, index) => (
          <HandCard
            key={card.id}
            card={card}
            index={index}
            isSelected={selectedCard?.id === card.id}
            canAfford={card.cost <= playerResources}
            isDraggable={isPlayerTurn && card.cost <= playerResources}
            onDragStart={(e) => onDragStart(card, e)}
          />
        ))}
      </div>

      <div className="resource-display">
        <span className="resource-count">{playerResources}</span>
        <span className="resource-label">Void Echoes</span>
      </div>
    </div>
  );
};
```

#### Grid Cell Component
```typescript
const GridCell: React.FC<GridCellProps> = ({
  position,
  unit,
  isValidDrop,
  isPlayerSide,
  faction,
  onDrop,
  onDragOver
}) => {
  const [isDragOver, setIsDragOver] = useState(false);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    if (isValidDrop) {
      setIsDragOver(true);
      onDragOver(e);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);

    if (isValidDrop) {
      const cardId = e.dataTransfer.getData('cardId');
      onDrop(cardId, position);
    }
  };

  return (
    <div
      className={`grid-cell ${getGridCellClasses()}`}
      onDragOver={handleDragOver}
      onDragLeave={() => setIsDragOver(false)}
      onDrop={handleDrop}
    >
      {unit && <UnitCard unit={unit} />}
      {isDragOver && isValidDrop && <DropPreview />}
    </div>
  );

  function getGridCellClasses() {
    const classes = [];

    if (isPlayerSide) classes.push('player-side');
    else classes.push('opponent-side');

    classes.push(`faction-${faction}`);

    if (isValidDrop) classes.push('valid-drop');
    if (isDragOver && isValidDrop) classes.push('drag-over');
    if (unit) classes.push('occupied');

    return classes.join(' ');
  }
};
```

### Custom Hooks

#### useDragDrop Hook
```typescript
const useDragDrop = (gameState: GameState, onCardPlace: PlaceCardFunction) => {
  const [dragDropState, setDragDropState] = useState<DragDropState>({
    draggedCard: null,
    dragPreview: null,
    validPositions: [],
    isDragging: false
  });

  const startDrag = (card: Card) => {
    const validPositions = calculateValidPositions(card, gameState);

    setDragDropState({
      draggedCard: card,
      dragPreview: null,
      validPositions,
      isDragging: true
    });
  };

  const updateDragPosition = (position: Position) => {
    if (dragDropState.validPositions.some(pos =>
      pos.x === position.x && pos.y === position.y
    )) {
      setDragDropState(prev => ({
        ...prev,
        dragPreview: position
      }));
    }
  };

  const handleDrop = async (position: Position) => {
    if (!dragDropState.draggedCard) return;

    try {
      await onCardPlace(dragDropState.draggedCard.id, position);
      endDrag();
    } catch (error) {
      console.error('Placement failed:', error);
      // Error handling will be done by parent component
      endDrag();
    }
  };

  const endDrag = () => {
    setDragDropState({
      draggedCard: null,
      dragPreview: null,
      validPositions: [],
      isDragging: false
    });
  };

  return {
    dragDropState,
    startDrag,
    endDrag,
    updateDragPosition,
    handleDrop
  };
};
```

#### Position Validation
```typescript
const calculateValidPositions = (card: Card, gameState: GameState): Position[] => {
  const { currentPlayer, playerData } = gameState;
  const formation = FACTION_FORMATIONS[playerData.faction];
  const validPositions: Position[] = [];

  // Check each position in the formation
  for (let y = 0; y < 3; y++) {
    for (let x = 0; x < 5; x++) {
      // Check if position is valid for faction
      if (!formation[y][x]) continue;

      // Check if position is empty
      if (playerData.board[y][x] !== null) continue;

      // Check if player can afford the card
      if (card.cost > playerData.resources) continue;

      validPositions.push({ x, y });
    }
  }

  return validPositions;
};
```

## üé® Visual Design

### CSS Styling Structure
```css
/* Game Board Layout */
.game-board {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(135deg, #1a1a2e, #16213e);
}

.opponent-board {
  flex: 1;
  padding: 1rem;
  transform: rotate(180deg); /* Opponent board upside down */
}

.player-board {
  flex: 1;
  padding: 1rem;
}

/* Grid Styling */
.player-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

.grid-cell {
  aspect-ratio: 1;
  border: 2px solid transparent;
  border-radius: 8px;
  position: relative;
  transition: all 0.2s ease;
}

/* Faction-specific grid styling */
.grid-cell.faction-humans {
  background: rgba(59, 130, 246, 0.1);
  border-color: rgba(59, 130, 246, 0.3);
}

.grid-cell.faction-aliens {
  background: rgba(34, 197, 94, 0.1);
  border-color: rgba(34, 197, 94, 0.3);
}

.grid-cell.faction-robots {
  background: rgba(239, 68, 68, 0.1);
  border-color: rgba(239, 68, 68, 0.3);
}

/* Drag and drop states */
.grid-cell.valid-drop {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.2);
}

.grid-cell.drag-over {
  border-color: #10b981;
  background: rgba(16, 185, 129, 0.4);
  transform: scale(1.05);
}

.grid-cell.invalid-drop {
  border-color: #ef4444;
  background: rgba(239, 68, 68, 0.2);
}

/* Hand Styling */
.hand-container {
  padding: 1rem;
  background: rgba(0, 0, 0, 0.3);
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.hand-cards {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

/* Card Styling */
.hand-card {
  width: 80px;
  height: 112px;
  border-radius: 8px;
  cursor: grab;
  transition: all 0.2s ease;
  position: relative;
}

.hand-card:hover {
  transform: translateY(-8px);
}

.hand-card.dragging {
  cursor: grabbing;
  opacity: 0.5;
}

.hand-card.unaffordable {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Animations */
@keyframes cardPlace {
  0% { transform: scale(1.2) rotate(5deg); opacity: 0.8; }
  100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

.card-placed {
  animation: cardPlace 0.3s ease-out;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .game-board {
    padding: 0.5rem;
  }

  .hand-card {
    width: 60px;
    height: 84px;
  }

  .player-grid {
    max-width: 100%;
    gap: 0.25rem;
  }
}
```

### Touch Support Implementation
```typescript
const useTouchDrag = () => {
  const [touchState, setTouchState] = useState<TouchDragState>({
    startPosition: { x: 0, y: 0 },
    currentPosition: { x: 0, y: 0 },
    isDragging: false,
    touchTarget: null
  });

  const handleTouchStart = (e: TouchEvent, card: Card) => {
    const touch = e.touches[0];
    setTouchState({
      startPosition: { x: touch.clientX, y: touch.clientY },
      currentPosition: { x: touch.clientX, y: touch.clientY },
      isDragging: true,
      touchTarget: e.target as Element
    });
  };

  const handleTouchMove = (e: TouchEvent) => {
    if (!touchState.isDragging) return;

    e.preventDefault();
    const touch = e.touches[0];
    setTouchState(prev => ({
      ...prev,
      currentPosition: { x: touch.clientX, y: touch.clientY }
    }));
  };

  const handleTouchEnd = (e: TouchEvent) => {
    if (!touchState.isDragging) return;

    const touch = e.changedTouches[0];
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);

    // Check if dropped on valid grid cell
    const gridCell = elementBelow?.closest('.grid-cell');
    if (gridCell && gridCell.classList.contains('valid-drop')) {
      const position = getPositionFromElement(gridCell);
      // Handle drop logic
    }

    setTouchState({
      startPosition: { x: 0, y: 0 },
      currentPosition: { x: 0, y: 0 },
      isDragging: false,
      touchTarget: null
    });
  };

  return {
    touchState,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  };
};
```

## üîå Integration Requirements

### Backend Integration
- Connect to placement backend (Task 1.3B) via Socket.io
- Handle placement validation responses
- Display server-side error messages
- Sync with real-time game state updates

### Socket.io Integration
```typescript
const useGamePlacement = () => {
  const socket = useSocket();

  const placeCard = async (cardId: string, position: Position): Promise<void> => {
    return new Promise((resolve, reject) => {
      socket.emit('game:place_unit', {
        cardId,
        position,
        handIndex: getHandIndex(cardId)
      }, (response: PlacementResponse) => {
        if (response.success) {
          resolve();
        } else {
          reject(new Error(response.error));
        }
      });
    });
  };

  return { placeCard };
};
```

### State Management
- Integrate with global game state from useGameSocket
- Update local state optimistically with server confirmation
- Handle state rollback on placement failures
- Maintain UI state consistency

## ‚úÖ Acceptance Criteria

### Drag & Drop Functionality
- [ ] Smooth card dragging on desktop and mobile
- [ ] Visual feedback for valid/invalid positions
- [ ] Ghost preview at drop location
- [ ] Touch-friendly mobile interaction
- [ ] Proper error handling for failed drops

### Visual Design
- [ ] Clear faction-specific grid styling
- [ ] Responsive layout for all screen sizes
- [ ] Smooth animations and transitions
- [ ] Professional UI polish
- [ ] Accessibility features (keyboard navigation, screen readers)

### Integration
- [ ] Real-time synchronization with backend
- [ ] Error messages displayed to user
- [ ] State consistency maintained
- [ ] Performance >60fps during interactions

### User Experience
- [ ] Intuitive drag and drop mechanics
- [ ] Clear visual feedback for all states
- [ ] Responsive design works on mobile
- [ ] Loading states and error handling

## üß™ Testing Strategy

### Component Tests
- Drag and drop event handling
- Position validation logic
- Visual state transitions
- Touch interaction support

### Integration Tests
- Socket.io event integration
- Backend placement validation
- State synchronization
- Error handling scenarios

### E2E Tests
- Complete card placement workflow
- Mobile touch interactions
- Cross-browser compatibility
- Performance under load

### Accessibility Tests
- Keyboard navigation
- Screen reader compatibility
- Color contrast compliance
- Focus management

## üì¶ Deliverables

1. **GameBoard Component**: Complete drag & drop interface
2. **Hand Component**: Interactive card hand with resource display
3. **Grid Components**: Faction-specific game board grids
4. **Custom Hooks**: useDragDrop and touch support hooks
5. **Styling**: Complete CSS with responsive design
6. **Integration**: Socket.io and state management integration
7. **Tests**: Comprehensive test suite for all functionality
8. **Documentation**: Component API and integration guides

## üöÄ Implementation Notes

### Performance Optimizations
- Use React.memo for grid cells to prevent unnecessary re-renders
- Implement virtual scrolling for large hands (future)
- Debounce drag position updates
- Optimize CSS animations for 60fps

### Accessibility Considerations
- ARIA labels for all interactive elements
- Keyboard shortcuts for card placement
- High contrast mode support
- Screen reader announcements for game actions

### Mobile Considerations
- Touch-friendly drag targets (minimum 44px)
- Haptic feedback for touch interactions
- Prevent scroll during drag operations
- Optimize for landscape orientation

This implementation creates an intuitive and responsive interface that makes tactical card placement engaging and accessible across all devices.