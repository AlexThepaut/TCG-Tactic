# 1.2C: Frontend WebSocket Integration

## üéØ Task Overview
**Agent**: @frontend-architect
**Duration**: 4 hours
**Dependencies**: 1.2A (WebSocket Infrastructure), 1.1D (Frontend Setup)
**Risk Level**: Medium
**Parallel Execution**: ‚ùå Sequential after WebSocket infrastructure

## üìã Objective
Implement React WebSocket integration with useSocket hook, event handling, connection management, and TypeScript event types for real-time game communication.

## üéØ Deliverables

### 1. Socket Service
```typescript
// src/services/socketService.ts
import { io, Socket } from 'socket.io-client';
import { GameState, GameEvent } from '@types/game';

class SocketService {
  private socket: Socket | null = null;
  private connected = false;

  connect(token: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket = io(import.meta.env.VITE_WS_URL || 'ws://localhost:5000', {
        auth: { token },
        transports: ['websocket', 'polling']
      });

      this.socket.on('connect', () => {
        this.connected = true;
        resolve();
      });

      this.socket.on('connect_error', (error) => {
        reject(error);
      });

      this.socket.on('disconnect', () => {
        this.connected = false;
      });
    });
  }

  disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.connected = false;
    }
  }

  emit<T = any>(event: string, data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      if (!this.socket || !this.connected) {
        reject(new Error('Socket not connected'));
        return;
      }

      this.socket.emit(event, data, (response: any) => {
        if (response.success) {
          resolve(response.data || response);
        } else {
          reject(new Error(response.error || 'Unknown error'));
        }
      });
    });
  }

  on(event: string, callback: (data: any) => void): void {
    if (this.socket) {
      this.socket.on(event, callback);
    }
  }

  off(event: string, callback?: (data: any) => void): void {
    if (this.socket) {
      this.socket.off(event, callback);
    }
  }

  isConnected(): boolean {
    return this.connected;
  }
}

export const socketService = new SocketService();
```

### 2. useSocket Hook
```typescript
// src/hooks/useSocket.ts
import { useEffect, useRef, useCallback } from 'react';
import { socketService } from '@services/socketService';
import { useAuth } from './useAuth';
import { useToast } from './useToast';

export function useSocket() {
  const { token } = useAuth();
  const { showError } = useToast();
  const isConnecting = useRef(false);

  const connect = useCallback(async () => {
    if (!token || isConnecting.current || socketService.isConnected()) {
      return;
    }

    isConnecting.current = true;
    try {
      await socketService.connect(token);
    } catch (error) {
      showError('Failed to connect to game server');
    } finally {
      isConnecting.current = false;
    }
  }, [token, showError]);

  const disconnect = useCallback(() => {
    socketService.disconnect();
  }, []);

  const emit = useCallback(async <T = any>(event: string, data: any): Promise<T> => {
    try {
      return await socketService.emit<T>(event, data);
    } catch (error) {
      showError(error instanceof Error ? error.message : 'Socket error');
      throw error;
    }
  }, [showError]);

  const on = useCallback((event: string, callback: (data: any) => void) => {
    socketService.on(event, callback);
  }, []);

  const off = useCallback((event: string, callback?: (data: any) => void) => {
    socketService.off(event, callback);
  }, []);

  useEffect(() => {
    if (token) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [token, connect, disconnect]);

  return {
    connect,
    disconnect,
    emit,
    on,
    off,
    isConnected: socketService.isConnected()
  };
}
```

### 3. Game Socket Hook
```typescript
// src/hooks/useGameSocket.ts
import { useEffect, useCallback } from 'react';
import { useSocket } from './useSocket';
import { GameState, CombatResult } from '@types/game';

interface UseGameSocketProps {
  gameId?: string;
  onStateUpdate?: (gameState: GameState) => void;
  onCombatResult?: (result: CombatResult) => void;
  onTurnChanged?: (data: { currentPlayer: number; turn: number; phase: string }) => void;
  onGameOver?: (data: { winner: number; reason: string }) => void;
}

export function useGameSocket({
  gameId,
  onStateUpdate,
  onCombatResult,
  onTurnChanged,
  onGameOver
}: UseGameSocketProps) {
  const { emit, on, off, isConnected } = useSocket();

  // Game actions
  const createGame = useCallback(async (deckId: string) => {
    return await emit('game:create', { deckId });
  }, [emit]);

  const joinGame = useCallback(async (gameId: string, deckId: string) => {
    return await emit('game:join', { gameId, deckId });
  }, [emit]);

  const placeUnit = useCallback(async (cardId: string, position: { row: number; col: number }) => {
    if (!gameId) return;
    return await emit('game:place_unit', { gameId, cardId, position });
  }, [emit, gameId]);

  const attackUnit = useCallback(async (
    attackerPos: { row: number; col: number },
    targetPos: { row: number; col: number }
  ) => {
    if (!gameId) return;
    return await emit('game:attack', { gameId, attackerPos, targetPos });
  }, [emit, gameId]);

  const endTurn = useCallback(async () => {
    if (!gameId) return;
    return await emit('game:end_turn', { gameId });
  }, [emit, gameId]);

  // Event listeners
  useEffect(() => {
    if (!isConnected) return;

    if (onStateUpdate) {
      on('game:state_update', onStateUpdate);
    }
    if (onCombatResult) {
      on('game:combat_result', onCombatResult);
    }
    if (onTurnChanged) {
      on('game:turn_changed', onTurnChanged);
    }
    if (onGameOver) {
      on('game:game_over', onGameOver);
    }

    return () => {
      off('game:state_update', onStateUpdate);
      off('game:combat_result', onCombatResult);
      off('game:turn_changed', onTurnChanged);
      off('game:game_over', onGameOver);
    };
  }, [isConnected, gameId, on, off, onStateUpdate, onCombatResult, onTurnChanged, onGameOver]);

  return {
    createGame,
    joinGame,
    placeUnit,
    attackUnit,
    endTurn,
    isConnected
  };
}
```

## ‚úÖ Acceptance Criteria
- [ ] Socket connection working from frontend
- [ ] Event emission and acknowledgment functional
- [ ] React hooks properly managing socket state
- [ ] TypeScript types for all events
- [ ] Connection recovery working

## üîß SuperClaude Command
```bash
@Task "frontend-architect" "Implement React WebSocket integration for TCG Tactique:

SOCKET SERVICE:
- Socket.io client service with connection management
- Promise-based event emission with error handling
- Connection state tracking and recovery
- TypeScript interfaces for all events

REACT HOOKS:
- useSocket hook for basic socket functionality
- useGameSocket hook for game-specific events
- Automatic connection management based on auth state
- Event cleanup and memory leak prevention

VALIDATION:
- Socket connection from frontend working
- Event emission and acknowledgment functional
- Real-time updates received correctly
- Error handling comprehensive"
```