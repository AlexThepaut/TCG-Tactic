# 1.2B: Game State Management

## üéØ Task Overview
**Agent**: @backend-architect
**Duration**: 6 hours
**Dependencies**: 1.2A (WebSocket Infrastructure), 1.1B (Database Schema)
**Risk Level**: Medium
**Parallel Execution**: ‚ùå Sequential after WebSocket setup

## üìã Objective
Create game state service with validation, persistence, synchronization, and concurrent access handling for TCG game mechanics. Core game logic foundation.

## üéØ Deliverables

### 1. Game State Interface
```typescript
// src/types/gameState.ts
export interface GameState {
  id: string;
  players: {
    player1: PlayerState;
    player2: PlayerState;
  };
  currentPlayer: number;
  turn: number;
  phase: 'resources' | 'draw' | 'actions';
  gameOver: boolean;
  winner?: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface PlayerState {
  id: number;
  faction: 'humans' | 'aliens' | 'robots';
  hand: Card[];
  board: (Card | null)[][]; // 3x5 grid
  resources: number; // Void Echoes 0-10
  deckRemaining: number;
  graveyard: Card[];
  questId?: string; // Secret
  hasAttacked: Set<string>; // Units that attacked this turn
}
```

### 2. Game State Service
```typescript
// src/services/gameStateService.ts
import { GameState, PlayerState } from '../types/gameState';
import { pool } from '../config/database';
import { logger } from '../utils/logger';

export class GameStateService {
  async createGameState(player1Id: number, player2Id: number): Promise<GameState> {
    const gameState: GameState = {
      id: this.generateGameId(),
      players: {
        player1: this.initializePlayer(player1Id),
        player2: this.initializePlayer(player2Id)
      },
      currentPlayer: 1,
      turn: 1,
      phase: 'resources',
      gameOver: false,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    await this.persistGameState(gameState);
    return gameState;
  }

  async updateGameState(gameId: string, updates: Partial<GameState>): Promise<GameState> {
    const currentState = await this.getGameState(gameId);
    const newState = {
      ...currentState,
      ...updates,
      updatedAt: new Date()
    };

    await this.persistGameState(newState);
    return newState;
  }

  async validateGameAction(
    gameState: GameState,
    playerId: number,
    action: GameAction
  ): Promise<ValidationResult> {
    // Validate turn order
    if (gameState.currentPlayer !== playerId) {
      return { valid: false, error: 'Not your turn' };
    }

    // Validate game phase
    if (action.type === 'place_unit' && gameState.phase !== 'actions') {
      return { valid: false, error: 'Wrong phase for this action' };
    }

    // Action-specific validation
    switch (action.type) {
      case 'place_unit':
        return this.validateUnitPlacement(gameState, playerId, action);
      case 'attack':
        return this.validateAttack(gameState, playerId, action);
      default:
        return { valid: true };
    }
  }

  private initializePlayer(playerId: number): PlayerState {
    return {
      id: playerId,
      faction: 'humans', // Will be set based on deck
      hand: [],
      board: Array(3).fill(null).map(() => Array(5).fill(null)),
      resources: 1,
      deckRemaining: 40,
      graveyard: [],
      hasAttacked: new Set()
    };
  }

  private async persistGameState(gameState: GameState): Promise<void> {
    const client = await pool.connect();
    try {
      await client.query(
        `INSERT INTO game_states (id, player1_id, player2_id, current_player, turn, phase, board_state_json, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
         ON CONFLICT (id) DO UPDATE SET
         current_player = $4, turn = $5, phase = $6, board_state_json = $7, created_at = $8`,
        [
          gameState.id,
          gameState.players.player1.id,
          gameState.players.player2.id,
          gameState.currentPlayer,
          gameState.turn,
          gameState.phase,
          JSON.stringify(gameState),
          gameState.updatedAt
        ]
      );
    } finally {
      client.release();
    }
  }
}
```

## ‚úÖ Acceptance Criteria
- [ ] Game state CRUD operations working
- [ ] State validation logic implemented
- [ ] Persistence to database functional
- [ ] Concurrent access handling
- [ ] State synchronization working

## üîß SuperClaude Command
```bash
@Task "backend-architect" "Create game state management system for TCG Tactique:

GAME STATE:
- Complete GameState and PlayerState interfaces
- Game state service with CRUD operations
- Validation logic for all game actions
- State persistence to PostgreSQL

VALIDATION:
- Turn order validation
- Phase-based action validation
- Unit placement validation
- Attack validation

VALIDATION:
- State operations work correctly
- Validation catches invalid actions
- Persistence maintains data integrity
- Concurrent access handled safely"
```