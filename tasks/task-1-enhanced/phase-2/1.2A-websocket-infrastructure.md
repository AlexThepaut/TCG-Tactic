# 1.2A: WebSocket Infrastructure

## ðŸŽ¯ Task Overview
**Agent**: @backend-architect
**Duration**: 4 hours
**Dependencies**: 1.1C (Backend Core)
**Risk Level**: Medium
**Parallel Execution**: âŒ Sequential after backend core

## ðŸ“‹ Objective
Implement Socket.io server with room management, connection handling, and basic event system for real-time game communication. Foundation for all multiplayer functionality.

## ðŸŽ¯ Deliverables

### 1. Socket.io Server Setup
```typescript
// src/socket/socketServer.ts
import { Server } from 'socket.io';
import { Server as HttpServer } from 'http';
import { logger } from '../utils/logger';
import { authenticateSocket } from '../middleware/socketAuth';
import { gameEventHandlers } from './handlers/gameHandlers';
import { matchmakingHandlers } from './handlers/matchmakingHandlers';

export function setupSocketServer(httpServer: HttpServer) {
  const io = new Server(httpServer, {
    cors: {
      origin: process.env.FRONTEND_URL || 'http://localhost:3000',
      methods: ['GET', 'POST'],
      credentials: true
    },
    transports: ['websocket', 'polling']
  });

  // Authentication middleware
  io.use(authenticateSocket);

  io.on('connection', (socket) => {
    logger.info(`User connected: ${socket.data.userId}`);

    // Register event handlers
    gameEventHandlers(io, socket);
    matchmakingHandlers(io, socket);

    socket.on('disconnect', (reason) => {
      logger.info(`User disconnected: ${socket.data.userId}, reason: ${reason}`);
    });
  });

  return io;
}
```

### 2. Game Event Handlers
```typescript
// src/socket/handlers/gameHandlers.ts
import { Server, Socket } from 'socket.io';
import { gameService } from '../../services/gameService';
import { logger } from '../../utils/logger';

export function gameEventHandlers(io: Server, socket: Socket) {
  // Create game
  socket.on('game:create', async (data, callback) => {
    try {
      const game = await gameService.createGame(socket.data.userId, data.deckId);
      socket.join(`game:${game.id}`);
      callback({ success: true, gameId: game.id });
    } catch (error) {
      logger.error('Game creation failed:', error);
      callback({ success: false, error: error.message });
    }
  });

  // Join game
  socket.on('game:join', async (data, callback) => {
    try {
      const game = await gameService.joinGame(data.gameId, socket.data.userId, data.deckId);
      socket.join(`game:${data.gameId}`);
      
      // Notify both players
      io.to(`game:${data.gameId}`).emit('game:player_joined', {
        gameId: data.gameId,
        players: game.players
      });
      
      callback({ success: true, game });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // Place unit
  socket.on('game:place_unit', async (data, callback) => {
    try {
      const result = await gameService.placeUnit(
        data.gameId,
        socket.data.userId,
        data.cardId,
        data.position
      );
      
      // Broadcast state update
      io.to(`game:${data.gameId}`).emit('game:state_update', result.gameState);
      
      callback({ success: true });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // Attack
  socket.on('game:attack', async (data, callback) => {
    try {
      const result = await gameService.attackUnit(
        data.gameId,
        socket.data.userId,
        data.attackerPos,
        data.targetPos
      );
      
      // Broadcast combat result
      io.to(`game:${data.gameId}`).emit('game:combat_result', result.combatResult);
      io.to(`game:${data.gameId}`).emit('game:state_update', result.gameState);
      
      callback({ success: true });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // End turn
  socket.on('game:end_turn', async (data, callback) => {
    try {
      const result = await gameService.endTurn(data.gameId, socket.data.userId);
      
      io.to(`game:${data.gameId}`).emit('game:turn_changed', {
        currentPlayer: result.currentPlayer,
        turn: result.turn,
        phase: result.phase
      });
      
      io.to(`game:${data.gameId}`).emit('game:state_update', result.gameState);
      
      callback({ success: true });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });
}
```

## âœ… Acceptance Criteria
- [ ] Socket.io server starts successfully
- [ ] Room management working (join/leave)
- [ ] Event handlers responding correctly
- [ ] Authentication middleware functional
- [ ] Error handling comprehensive

## ðŸ”§ SuperClaude Command
```bash
@Task "backend-architect" "Implement Socket.io infrastructure for TCG Tactique real-time communication:

SOCKET SERVER:
- Socket.io server with CORS and transport configuration
- Room management for game sessions
- Authentication middleware for socket connections
- Connection/disconnection logging and handling

EVENT SYSTEM:
- Game events: create, join, place_unit, attack, end_turn
- State synchronization between players
- Error handling with proper callback responses
- Broadcasting to game rooms

VALIDATION:
- Socket connections work from frontend
- Room joining and leaving functional
- Event emission and acknowledgment working
- Authentication properly validated"
```

## ðŸ“Š Success Metrics
- **Connection Time**: < 500ms
- **Event Latency**: < 100ms
- **Room Management**: 100% reliable
- **Error Rate**: < 1%